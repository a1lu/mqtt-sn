//
// Copyright 2016 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#include "comms/comms.h"
#include "mqttsn/client/common.h"
#include "client.h"

CC_DISABLE_WARNINGS()
#include "cxxtest/TestSuite.h"
CC_ENABLE_WARNINGS()

#include "CommonTestClient.h"
#include "DataProcessor.h"

class ClientBasic : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();
    void test26();

private:
    typedef DataProcessor::DataBuf DataBuf;

    typedef DataProcessor::AdvertiseMsg AdvertiseMsg;
    typedef DataProcessor::SearchgwMsg SearchgwMsg;
    typedef DataProcessor::GwinfoMsg GwinfoMsg;
    typedef DataProcessor::ConnectMsg ConnectMsg;
    typedef DataProcessor::ConnackMsg ConnackMsg;
    typedef DataProcessor::WilltopicreqMsg WilltopicreqMsg;
    typedef DataProcessor::WilltopicMsg WilltopicMsg;
    typedef DataProcessor::WillmsgreqMsg WillmsgreqMsg;
    typedef DataProcessor::WillmsgMsg WillmsgMsg;
    typedef DataProcessor::RegisterMsg RegisterMsg;
    typedef DataProcessor::RegackMsg RegackMsg;
    typedef DataProcessor::PublishMsg PublishMsg;
    typedef DataProcessor::PubackMsg PubackMsg;
    typedef DataProcessor::PubrecMsg PubrecMsg;
    typedef DataProcessor::PubrelMsg PubrelMsg;
    typedef DataProcessor::PubcompMsg PubcompMsg;
    typedef DataProcessor::PingreqMsg PingreqMsg;
    typedef DataProcessor::PingrespMsg PingrespMsg;
    typedef DataProcessor::DisconnectMsg DisconnectMsg;

    static const unsigned DefaultAdvertisePeriod = 5 * 60 * 1000;
    static const unsigned DefaultRetryTimeout = 5 * 1000;
    static const unsigned DefaultRetryCount = 3;
    static const unsigned char DefaultBroadcastRadius = 0;
    static const unsigned short DefaultKeepAlive = 60;

    typedef std::vector<std::uint8_t> DataSeq;

    struct ReportedMsgInfo
    {
        ReportedMsgInfo(const MqttsnMessageInfo& info)
          : m_topic(info.topic),
            m_topicId(info.topicId),
            m_data(info.msg, info.msg + info.msgLen),
            m_qos(info.qos),
            m_retain(info.retain)
        {
        }

        std::string m_topic;
        MqttsnTopicId m_topicId = 0;
        std::vector<std::uint8_t> m_data;
        MqttsnQoS m_qos = MqttsnQoS_NoGwPublish;
        bool m_retain = false;
    };

    struct ReportedGwInfo
    {
        ReportedGwInfo(std::uint16_t id, MqttsnGwStatus status)
          : m_id(id),
            m_status(status)
        {
        }

        unsigned short m_id = 0U;
        MqttsnGwStatus m_status = MqttsnGwStatus_Invalid;
    };

    struct TestBasicState
    {
        unsigned m_nextRequestedTicks = 0;
        unsigned m_nextElapsedTicks = 0;
        DataSeq m_nextOutput;
        bool m_broadcast;
        std::list<ReportedMsgInfo> m_reportedMsgs;
        std::list<ReportedGwInfo> m_reportedGws;
        std::list<MqttsnConnectionStatus> m_reportedConnStatuses;
    };

    template <typename TState>
    void clearState(TState& state)
    {
        state = TState();
    }

    void dataFromGw(CommonTestClient& client, const DataBuf& buf, const std::string& msg)
    {
        if (!msg.empty()) {
            TS_TRACE("--> " + msg);
        }
        client.inputData(&buf[0], buf.size());
    }

    typedef CommonTestClient::Ptr ClientPtr;
    ClientPtr allocClient(TestBasicState* state = nullptr, DataProcessor* dataProc = nullptr)
    {
        auto ptr = CommonTestClient::alloc();
        assert(ptr);
        ptr->setGwAdvertisePeriod(DefaultAdvertisePeriod);
        ptr->setRetryPeriod(DefaultRetryTimeout);
        ptr->setRetryCount(DefaultRetryCount);
        ptr->setBroadcastRadius(DefaultBroadcastRadius);
        ptr->setConnectionStatusReportCallback(
            [state](MqttsnConnectionStatus val)
            {
                TS_TRACE("Connect status reported: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedConnStatuses.push_back(val);
                }
            });
        ptr->setPublishCompleteCallback(
            [](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Publish complete with status: " + std::to_string((int)val));
            });
        ptr->setMessageReportCallback(
            [state](const MqttsnMessageInfo& msgInfo)
            {
                TS_TRACE(std::string("Received message with topic ") + msgInfo.topic);
                if (state != nullptr) {
                    state->m_reportedMsgs.push_back(msgInfo);
                }
            });
        ptr->setGwStatusReportCallback(
            [state](unsigned short gwId, MqttsnGwStatus status)
            {
                TS_TRACE(std::string("GW info reported: id=") + std::to_string(gwId) + "; status=" + std::to_string(status));
                if (state != nullptr) {
                    state->m_reportedGws.push_back(ReportedGwInfo(gwId, status));
                }
            });

        if (state != nullptr) {
            ptr->setProgramNextTickCallback(
                [state](unsigned duration)
                {
                    state->m_nextRequestedTicks = duration;
                });

            ptr->setCancelNextTickCallback(
                [state]() -> unsigned
                {
                    return state->m_nextElapsedTicks;
                });

            ptr->setSendDataCallback(
                [state](const std::uint8_t* buf, unsigned bufLen, bool broadcast)
                {
                    assert(state->m_nextOutput.empty());
//                    TS_TRACE("Sending " + std::to_string(bufLen) + " bytes; broadcast=" + std::to_string(broadcast));
                    state->m_nextOutput.insert(state->m_nextOutput.end(), buf, buf + bufLen);
                    state->m_broadcast = broadcast;
                });

        }

        if (dataProc != nullptr)
        {
            dataProc->setSearchgwMsgReportCallback(
                [](const SearchgwMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- SEARCHGW");
                });

            dataProc->setConnectMsgReportCallback(
                [](const ConnectMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- CONNECT");
                });

            dataProc->setWilltopicMsgReportCallback(
                [](const WilltopicMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLTOPIC");
                });

            dataProc->setWillmsgMsgReportCallback(
                [](const WillmsgMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLMSG");
                });

            dataProc->setRegisterMsgReportCallback(
                [](const RegisterMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGISTER");
                });

            dataProc->setRegackMsgReportCallback(
                [](const RegackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGACK");
                });

            dataProc->setPublishMsgReportCallback(
                [](const PublishMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBLISH");
                });

            dataProc->setPubackMsgReportCallback(
                [](const PubackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBACK");
                });

            dataProc->setPubrecMsgReportCallback(
                [](const PubrecMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREC");
                });

            dataProc->setPubrelMsgReportCallback(
                [](const PubrelMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREL");
                });

            dataProc->setPubcompMsgReportCallback(
                [](const PubcompMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBCOMP");
                });

            dataProc->setPingreqMsgReportCallback(
                [](const PingreqMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGREQ");
                });

            dataProc->setPingrespMsgReportCallback(
                [](const PingrespMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGRESP");
                });

        }

        return std::move(ptr);
    }

    void doGwInfo(CommonTestClient& client, DataProcessor& dataProc, TestBasicState& state)
    {
        verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);

        clearState(state);
        static const std::uint8_t GwId = 5U;
        auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
        TS_ASSERT(!gwInfoData.empty());

        state.m_nextElapsedTicks = 1 * 1000;
        dataFromGw(client, gwInfoData, "GWINFO");
        verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    }

    void doConnect(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        bool hasWill = false)
    {

        static const std::string ClientId = "test_client";
        static const std::string WillTopic("/this/is/will");
        static const std::vector<std::uint8_t> WillData{
            0x1, 0x2, 0x3, 0x4
        };
        static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
        static const bool WillRetain = false;

        static const auto WillInfoCreateFunc =
            []() -> MqttsnWillInfo
            {
                auto willInfo = MqttsnWillInfo();
                willInfo.topic = WillTopic.c_str();
                willInfo.msg = &WillData[0];
                willInfo.msgLen = WillData.size();
                willInfo.qos = WillQos;
                willInfo.retain = WillRetain;
                return willInfo;
            };

        static const MqttsnWillInfo WillInfo = WillInfoCreateFunc();
        TS_TRACE("Connecting...");
        state.m_nextElapsedTicks = 0;

        const MqttsnWillInfo* willInfo = nullptr;
        if (hasWill) {
            willInfo = &WillInfo;
        }
        auto result =
            client.connect(ClientId.c_str(), DefaultKeepAlive, true, willInfo);
        TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
        verifySent_ConnectMsg(state, dataProc, ClientId, DefaultKeepAlive, true, willInfo != nullptr);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

        clearState(state);

        if (hasWill) {
            auto willTopicReq = dataProc.prepareWilltopicreqMsg();
            dataFromGw(client, willTopicReq, "WILLTOPICREQ");
            verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

            clearState(state);
            auto willMsgReq = dataProc.prepareWillmsgreqMsg();
            dataFromGw(client, willMsgReq, "WILLMSGREQ");
            verifySent_WillmsgMsg(state, dataProc, WillData);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

            clearState(state);
        }

        auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
        dataFromGw(client, connackMsg, "CONNACK");
        verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Connected);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
    }

    void startClient(CommonTestClient& client)
    {
        bool result = client.start();
        TS_ASSERT(result);
    }

    void doTopicRegister(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        const std::string& topic,
        MqttsnTopicId topicId,
        std::uint16_t msgId)
    {
        bool regackSent = false;
        auto oldCb = dataProc.setRegackMsgReportCallback(
            [&](const RegackMsg& msg)
            {
                regackSent = true;
                TS_TRACE("<-- REGACK");

                auto& fields = msg.fields();
                auto& topicIdField = std::get<RegackMsg::FieldIdx_topicId>(fields);
                auto& msgIdField = std::get<RegackMsg::FieldIdx_msgId>(fields);
                auto& retCodeField = std::get<RegackMsg::FieldIdx_returnCode>(fields);

                TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                TS_ASSERT_EQUALS(retCodeField.value(), mqttsn::protocol::field::ReturnCodeVal_Accepted);
            });


        clearState(state);
        auto registerMsg = dataProc.prepareRegisterMsg(topicId, msgId, topic);
        state.m_nextElapsedTicks = 1000;
        dataFromGw(client, registerMsg, "REGISTER");

        TS_ASSERT(!state.m_nextOutput.empty());
        TS_ASSERT(!state.m_broadcast);
        dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

        TS_ASSERT(regackSent);

        dataProc.setRegackMsgReportCallback(std::move(oldCb));
    }

    void processOutput(
        const TestBasicState& state,
        DataProcessor& dataProc,
        bool broadcast = false)
    {
        TS_ASSERT(!state.m_nextOutput.empty());
        TS_ASSERT_EQUALS(state.m_broadcast, broadcast);
        dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());
    }

    void verifySent_SearchgwMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        unsigned short radius)
    {
        bool sent = false;
        auto oldCb = dataProc.setSearchgwMsgReportCallback(
            [&sent, radius](const SearchgwMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- SEARCHGW");
                auto& fields = msg.fields();
                auto& radiusField = std::get<SearchgwMsg::FieldIdx_radus>(fields);
                TS_ASSERT_EQUALS(radiusField.value(), radius);
            });

        processOutput(state, dataProc, true);
        TS_ASSERT(sent);

        dataProc.setSearchgwMsgReportCallback(std::move(oldCb));
    }

    void verifySent_ConnectMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& clientId,
        unsigned short keepAlivePeriod,
        bool cleanSession,
        bool hasWill)
    {
        bool sent = false;
        auto oldCb = dataProc.setConnectMsgReportCallback(
            [&sent, &clientId, keepAlivePeriod, cleanSession, hasWill](const ConnectMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- CONNECT");
                auto& fields = msg.fields();
                auto& flagsField = std::get<ConnectMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& midFlags = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                auto& protocolIdField = std::get<ConnectMsg::FieldIdx_protocolId>(fields);
                auto& durationField = std::get<ConnectMsg::FieldIdx_duration>(fields);
                auto& clientIdField = std::get<ConnectMsg::FieldIdx_clientId>(fields);

                TS_ASSERT_EQUALS(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_cleanSession), cleanSession);
                TS_ASSERT_EQUALS(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_will), hasWill);
                TS_ASSERT_EQUALS(protocolIdField.value(), 1);
                TS_ASSERT_EQUALS(durationField.value(), keepAlivePeriod);
                TS_ASSERT_EQUALS(clientIdField.value(), clientId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);

        dataProc.setConnectMsgReportCallback(std::move(oldCb));
    }

    void verifySent_WilltopicMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic,
        MqttsnQoS qos,
        bool retain)
    {
        bool sent = false;
        auto oldCb = dataProc.setWilltopicMsgReportCallback(
            [&sent, &topic, qos, retain](const WilltopicMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- WILLTOPIC");
                auto& fields = msg.fields();
                auto& flagsField = std::get<WilltopicMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                auto& topicField = std::get<WilltopicMsg::FieldIdx_willTopic>(fields);

                TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), retain);
                TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), qos);
                TS_ASSERT_EQUALS(topicField.value(), topic);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWilltopicMsgReportCallback(std::move(oldCb));
    }

    void verifySent_WillmsgMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::vector<std::uint8_t>& data)
    {
        bool sent = false;
        auto oldCb = dataProc.setWillmsgMsgReportCallback(
            [&sent, &data](const WillmsgMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- WILLMSG");
                auto& fields = msg.fields();
                auto& willMsgField = std::get<WillmsgMsg::FieldIdx_willMsg>(fields);

                TS_ASSERT_EQUALS(willMsgField.value(), data);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWillmsgMsgReportCallback(std::move(oldCb));
    }

    void verifySent_PubackMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        std::uint16_t msgId,
        mqttsn::protocol::field::ReturnCodeVal retCode = mqttsn::protocol::field::ReturnCodeVal_Accepted)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubackMsgReportCallback(
            [&sent, topicId, msgId, retCode](const PubackMsg& msg)
            {
                TS_TRACE("<-- PUBACK");
                sent = true;

                auto& fields = msg.fields();
                auto& topicIdField = std::get<PubackMsg::FieldIdx_topicId>(fields);
                auto& msgIdField = std::get<PubackMsg::FieldIdx_msgId>(fields);
                auto& retCodeField = std::get<PubackMsg::FieldIdx_returnCode>(fields);

                TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                TS_ASSERT_EQUALS(retCodeField.value(), retCode);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubackMsgReportCallback(std::move(oldCb));
    }

    void verifySent_PubrecMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubrecMsgReportCallback(
            [&sent, msgId](const PubrecMsg& msg)
            {
                TS_TRACE("<-- PUBREC");
                sent = true;

                auto& fields = msg.fields();
                auto& msgIdField = std::get<PubrecMsg::FieldIdx_msgId>(fields);

                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubrecMsgReportCallback(std::move(oldCb));
    }

    void verifySent_PubcompMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubcompMsgReportCallback(
            [&sent, msgId](const PubcompMsg& msg)
            {
                TS_TRACE("<-- PUBCOMP");
                sent = true;

                auto& fields = msg.fields();
                auto& msgIdField = std::get<PubcompMsg::FieldIdx_msgId>(fields);

                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubcompMsgReportCallback(std::move(oldCb));
    }

    void verifyCb_ReportedGw(
        TestBasicState& state,
        std::uint16_t gwId,
        MqttsnGwStatus status)
    {
        TS_ASSERT(!state.m_reportedGws.empty());
        if (state.m_reportedGws.empty()) {
            return;
        }

        auto& gw = state.m_reportedGws.front();
        TS_ASSERT_EQUALS(gw.m_id, gwId);
        TS_ASSERT_EQUALS(gw.m_status, status);
        state.m_reportedGws.pop_front();
    }

    void verifyCb_ReportedMessage(
        TestBasicState& state,
        const std::string& topic,
        MqttsnTopicId topicId,
        const std::vector<std::uint8_t>& data,
        MqttsnQoS qos,
        bool retain)
    {
        TS_ASSERT(!state.m_reportedMsgs.empty());
        if (state.m_reportedMsgs.empty()) {
            return;
        }

        auto& msg = state.m_reportedMsgs.front();
        TS_ASSERT_EQUALS(msg.m_topic, topic);
        TS_ASSERT_EQUALS(msg.m_topicId, topicId);
        TS_ASSERT_EQUALS(msg.m_data, data);
        TS_ASSERT_EQUALS(msg.m_qos, qos);
        TS_ASSERT_EQUALS(msg.m_retain, retain);
        state.m_reportedMsgs.pop_front();
    }

    void verifyCb_ReportedConnStatus(
        TestBasicState& state,
        MqttsnConnectionStatus status)
    {
        TS_ASSERT(!state.m_reportedConnStatuses.empty());
        if (state.m_reportedConnStatuses.empty()) {
            return;
        }

        TS_ASSERT_EQUALS(state.m_reportedConnStatuses.front(), status);
        state.m_reportedConnStatuses.pop_front();
    }

    MqttsnQoS transformQos(mqttsn::protocol::field::QosType val)
    {
        return CommonTestClient::transformQos(val);
    }
};

void ClientBasic::test1()
{
    auto client = allocClient();
    static_cast<void>(client);
}

void ClientBasic::test2()
{
    DataProcessor dataProc;
    typedef TestBasicState Test2State;
    Test2State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    TS_TRACE("Started");
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    TS_TRACE("Tick");
    client->tick(DefaultRetryTimeout);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    static const std::uint8_t GwId = 5U;
    auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
    TS_ASSERT(!gwInfoData.empty());

    assert(state.m_nextRequestedTicks == 0U);
    state.m_nextElapsedTicks = 1 * 1000;
    dataFromGw(*client, gwInfoData, "GWINFO");

    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultAdvertisePeriod);

    clearState(state);
    client->tick(DefaultAdvertisePeriod);
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_TimedOut);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    auto advertiseData = dataProc.prepareAdvertiseMsg(GwId, (DefaultAdvertisePeriod / 1000) + 1);
    TS_ASSERT(!advertiseData.empty());
    state.m_nextElapsedTicks = 1 * 1000;

    dataFromGw(*client, advertiseData, "ADVERTISE");
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultAdvertisePeriod  + 1000);

    clearState(state);
    client->tick(DefaultAdvertisePeriod  + 1000);
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_TimedOut);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
}

void ClientBasic::test3()
{
    // Connect without will
    DataProcessor dataProc;
    struct Test3State : public TestBasicState
    {
        MqttsnConnectionStatus m_connectionStatus = MqttsnConnectionStatus_Invalid;
    };

    Test3State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            // First connect is expected to be timed out
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_Timeout);

            client->setConnectionStatusReportCallback(
                [&](MqttsnConnectionStatus val2)
                {
                    TS_TRACE("Connect status reported: " + std::to_string((int)val2));
                    TS_ASSERT_EQUALS(val2, MqttsnConnectionStatus_Connected);
                    state.m_connectionStatus = val2;
                });

            TS_TRACE("Reconnecting...");
            auto result2 =
                client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

            TS_ASSERT_EQUALS(result2, MqttsnErrorCode_Success);

        });

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);

    // Timeout and new connect attempt is expected here

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    clearState(state);
    auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");

    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Connected);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, KeepAlive * 1000);
}

void ClientBasic::test4()
{
    // Connect with will
    DataProcessor dataProc;
    typedef TestBasicState Test4State;

    Test4State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;
    static const std::string WillTopic("/this/is/will");
    static const std::vector<std::uint8_t> WillData{
        0x1, 0x2, 0x3, 0x4
    };
    static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool WillRetain = false;

    TS_TRACE("Connecting...");
    auto willInfo = MqttsnWillInfo();
    willInfo.topic = WillTopic.c_str();
    willInfo.msg = &WillData[0];
    willInfo.msgLen = WillData.size();
    willInfo.qos = WillQos;
    willInfo.retain = WillRetain;

    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, &willInfo);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);

    // Send ack message, check ignored
    state.m_nextElapsedTicks = 1000;
    auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");
    // Ack must be ignored
    TS_ASSERT(state.m_reportedConnStatuses.empty());
    TS_ASSERT(state.m_nextOutput.empty())

    auto willTopicReq = dataProc.prepareWilltopicreqMsg();
    dataFromGw(*client, willTopicReq, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);

    client->tick(nextTick); // Timeout is expected, new connect attempt

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, willTopicReq, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto willMsgReq = dataProc.prepareWillmsgreqMsg();
    dataFromGw(*client, willMsgReq, "WILLMSGREQ");
    verifySent_WillmsgMsg(state, dataProc, WillData);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, connackMsg, "CONNACK");

    // check connected
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Connected);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, KeepAlive * 1000);
}

// TODO: from here
void ClientBasic::test5()
{
    DataProcessor dataProc;
    struct Test5State : public TestBasicState
    {
        bool m_pingReqSent = false;
    };

    Test5State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    auto nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, DefaultKeepAlive * 1000);

    dataProc.setPingreqMsgReportCallback(
        [&](const PingreqMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- PINGREQ");
            state.m_pingReqSent = true;
        });

    auto checkPingreqMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pingReqSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    client->tick(nextTicks);
    checkPingreqMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingRespMsg = dataProc.preparePingrespMsg();
    dataFromGw(*client, pingRespMsg, "PINGRESP");

    TS_ASSERT(state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);

    nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, DefaultKeepAlive * 1000);

    clearState(state);
    client->tick(nextTicks);
    checkPingreqMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkPingreqMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkPingreqMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test6()
{
    DataProcessor dataProc;
    struct Test6State : public TestBasicState
    {
        bool m_pingRespSent = false;
    };

    Test6State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    dataProc.setPingrespMsgReportCallback(
        [&](const PingrespMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- PINGRESP");
            state.m_pingRespSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingreqMsg = dataProc.preparePingreqMsg();
    dataFromGw(*client, pingreqMsg, "PINGREQ");

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_pingRespSent);

    clearState(state);
    TS_ASSERT(state.m_reportedConnStatuses.empty());
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test7()
{
    DataProcessor dataProc;
    struct Test7State : public TestBasicState
    {
        bool m_disconnectSent = false;
    };

    Test7State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    dataProc.setDisconnectMsgReportCallback(
        [&](const DisconnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- DISCONNECT");
            state.m_disconnectSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_disconnectSent);

    TS_ASSERT(state.m_reportedConnStatuses.empty());
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    state.m_nextElapsedTicks = 1000;
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test8()
{
    DataProcessor dataProc;
    struct Test8State : public TestBasicState
    {
        bool m_disconnectSent = false;
    };

    Test8State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    dataProc.setDisconnectMsgReportCallback(
        [&](const DisconnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- DISCONNECT");
            state.m_disconnectSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkDisconnectFunc =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(state.m_nextOutput);
            TS_ASSERT(state.m_disconnectSent);

            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkDisconnectFunc();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkDisconnectFunc();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkDisconnectFunc();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);

    TS_ASSERT(state.m_nextOutput.empty());
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test9()
{
    DataProcessor dataProc;
    struct Test9State : public TestBasicState
    {
        bool m_connectMsgSent = false;
        bool m_connectionStatusReported = false;
    };

    Test9State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    dataProc.setConnectMsgReportCallback(
        [&](const ConnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- CONNECT");
            state.m_connectMsgSent = true;
        });

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            // First connect is expected to be timed out
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_ConnectAborted);
            state.m_connectionStatusReported = true;
        });

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkConnectMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_connectMsgSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkConnectMessage();

    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    checkConnectMessage();

    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    TS_ASSERT(state.m_connectionStatusReported)
}

void ClientBasic::test10()
{
    DataProcessor dataProc;
    struct Test10State : public TestBasicState
    {
        bool m_disconnectSent = false;
    };

    Test10State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    dataProc.setDisconnectMsgReportCallback(
        [&](const DisconnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- DISCONNECT");
            state.m_disconnectSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_disconnectSent);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    state.m_nextElapsedTicks = 1000;
    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test11()
{
    DataProcessor dataProc;
    struct Test11State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test11State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_publishCompleteReported);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_publishSent);

}

void ClientBasic::test12()
{
    DataProcessor dataProc;
    struct Test12State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test12State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);

    static const MqttsnTopicId TopicId = 0x0123;
    static const MqttsnQoS Qos = MqttsnQoS_NoGwPublish;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
        });

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), MqttsnQoS_AtMostOnceDelivery, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);
    TS_ASSERT(!state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty());

    result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_publishCompleteReported);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_publishSent);

}

void ClientBasic::test13()
{
    DataProcessor dataProc;
    struct Test13State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test13State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    bool mustBeDuplicate = false;
    std::uint16_t msgId = 0U;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    TS_ASSERT(!state.m_publishCompleteReported);
    checkPublishMessage();
    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);

    client->tick(nextTicks);
    mustBeDuplicate = true;
    checkPublishMessage();
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(!state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty()); // must be ignored

    clearState(state);
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
}

void ClientBasic::test14()
{
    DataProcessor dataProc;
    struct Test14State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test14State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_InvalidId);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            msgId = msgIdField.value();
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    TS_ASSERT(!state.m_publishCompleteReported);
    checkPublishMessage();
    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
}

void ClientBasic::test15()
{
    DataProcessor dataProc;
    struct Test15State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_pubrelSent = false;
        bool m_publishCompleteReported = false;
    };

    Test15State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    bool mustBeDuplicate = false;
    std::uint16_t msgId = 0U;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    dataProc.setPubrelMsgReportCallback(
        [&](const PubrelMsg& msg)
        {
            TS_TRACE("<-- PUBREL");
            state.m_pubrelSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubrelMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), msgId);
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    auto checkPubrelMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubrelSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkPublishMessage();
    clearState(state);

    state.m_nextElapsedTicks = 2000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");

    TS_ASSERT(!state.m_publishCompleteReported);
    checkPubrelMessage();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);

    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);
    mustBeDuplicate = true;
    checkPublishMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");

    TS_ASSERT(!state.m_publishCompleteReported);
    checkPubrelMessage();

    clearState(state);
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    TS_ASSERT(state.m_publishCompleteReported);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test16()
{
    DataProcessor dataProc;
    struct Test16State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test16State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty());

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
    TS_ASSERT(state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    checkPublishMessage();
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000 - state.m_nextElapsedTicks);
}

void ClientBasic::test17()
{
    DataProcessor dataProc;
    struct Test17State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishCompleteReported = false;
    };

    Test17State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_NoResponse);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);

    checkRegisterMessage();
    TS_ASSERT(!state.m_publishCompleteReported);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkRegisterMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty());
}

void ClientBasic::test18()
{
    DataProcessor dataProc;
    struct Test18State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test18State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);

    mustBeDuplicate = true;
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test19()
{
    DataProcessor dataProc;
    struct Test19State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test19State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_registerSent);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test20()
{
    DataProcessor dataProc;
    struct Test20State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test20State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_InvalidId);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test21()
{
    DataProcessor dataProc;
    struct Test21State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_pubrelSent = false;
        MqttsnAsyncOpStatus m_publishCompleteStatus = MqttsnAsyncOpStatus_Invalid;
    };

    Test21State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            state.m_publishCompleteStatus = status;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            msgId = msgIdField.value();

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    dataProc.setPubrelMsgReportCallback(
        [&](const PubrelMsg& msg)
        {
            TS_TRACE("<-- PUBREL");
            state.m_pubrelSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubrelMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            TS_TRACE("msgId=" + std::to_string(msgId));
        });


    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Aborted);

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    auto checkPubrelMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubrelSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");

    checkPubrelMessage();
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    TS_ASSERT_DIFFERS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Aborted);
    client->cancel();
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Aborted);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    checkPubrelMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test22()
{
    DataProcessor dataProc;
    struct Test22State : public TestBasicState
    {
        bool m_regackSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test22State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t RegMsgId = 0x1234;
    static const MqttsnTopicId TopicId = 0x2222;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    dataProc.setRegackMsgReportCallback(
        [&](const RegackMsg& msg)
        {
            TS_TRACE("<-- REGACK");
            state.m_regackSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegackMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegackMsg::FieldIdx_msgId>(fields);
            auto& retCodeField = std::get<RegackMsg::FieldIdx_returnCode>(fields);

            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(msgIdField.value(), RegMsgId);
            TS_ASSERT_EQUALS(retCodeField.value(), mqttsn::protocol::field::ReturnCodeVal_Accepted);
        });

     dataProc.setPublishMsgReportCallback(
         [&](const PublishMsg& msg)
         {
             TS_TRACE("<-- PUBLISH");
             state.m_publishSent = true;

             auto& fields = msg.fields();
             auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
             auto& flagsMembers = flagsField.value();
             auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
             auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
             auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
             auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
             auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
             auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

             TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
             TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
             TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
             TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
             TS_ASSERT_EQUALS(dataField.value(), Data);

             TS_TRACE("msgId=" + std::to_string(msgIdField.value()));
         });


    clearState(state);
    auto registerMsg = dataProc.prepareRegisterMsg(TopicId, RegMsgId, Topic);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, registerMsg, "REGISTER");

    auto checkRegackMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_regackSent);
        };

    checkRegackMessage();

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    checkPublishMessage();
    TS_ASSERT(state.m_publishCompleteReported);
}

void ClientBasic::test23()
{
    DataProcessor dataProc;
    struct Test23State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_regackSent = false;
        bool m_publishSent = false;
        bool m_pubrelSent = false;
        MqttsnAsyncOpStatus m_publishCompleteStatus = MqttsnAsyncOpStatus_Invalid;
    };

    Test23State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic1("this/is/topic1");
    static const std::string Topic2("this/is/topic2");
    static const MqttsnTopicId Topic1Id = 0x1234;
    static const MqttsnTopicId Topic2Id = 0x4321;
    static const std::uint16_t RegMsgId = 0x2222;
    static const MqttsnQoS Qos1 = MqttsnQoS_ExactlyOnceDelivery;
    static const MqttsnQoS Qos2 = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            state.m_publishCompleteStatus = status;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic1, topicNameField.value());
            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    dataProc.setRegackMsgReportCallback(
        [&](const RegackMsg& msg)
        {
            TS_TRACE("<-- REGACK");
            state.m_regackSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegackMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegackMsg::FieldIdx_msgId>(fields);
            auto& retCodeField = std::get<RegackMsg::FieldIdx_returnCode>(fields);

            TS_ASSERT_EQUALS(topicIdField.value(), Topic2Id);
            TS_ASSERT_EQUALS(msgIdField.value(), RegMsgId);
            TS_ASSERT_EQUALS(retCodeField.value(), mqttsn::protocol::field::ReturnCodeVal_Accepted);
        });

    bool mustBeDuplicate = false;
    MqttsnTopicId pubTopic = 0;
    MqttsnQoS pubQos = MqttsnQoS_NoGwPublish;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), pubQos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), pubTopic);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            msgId = msgIdField.value();

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    dataProc.setPubrelMsgReportCallback(
        [&](const PubrelMsg& msg)
        {
            TS_TRACE("<-- PUBREL");
            state.m_pubrelSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubrelMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            TS_TRACE("msgId=" + std::to_string(msgId));
        });


    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic1, &Data[0], Data.size(), Qos1, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(Topic1Id, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    pubTopic = Topic1Id;
    pubQos = Qos1;
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    doTopicRegister(*client, dataProc, state, Topic2, Topic2Id, RegMsgId);

    auto checkPubrelMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubrelSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");

    checkPubrelMessage();
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->publish(Topic2, &Data[0], Data.size(), Qos2, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    pubTopic = Topic2Id;
    pubQos = Qos2;
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(Topic2Id, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Successful);
}

void ClientBasic::test24()
{
    DataProcessor dataProc;
    struct Test24State : public TestBasicState
    {
        bool m_messageReported = false;
    };

    Test24State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x1234;
    static const std::uint16_t MsgId = 0x5555;
    static const auto Qos = mqttsn::protocol::field::QosType::AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    const char* expectedTopic = nullptr;
    client->setMessageReportCallback(
        [&](const MqttsnMessageInfo& info)
        {
            state.m_messageReported = true;

            if (expectedTopic == nullptr) {
                TS_TRACE("Message reported with topic ID " + std::to_string(info.topicId));
                TS_ASSERT_EQUALS(info.topic, expectedTopic);
            }
            else {
                TS_TRACE("Message reported with topic " + std::string(info.topic));
                TS_ASSERT_EQUALS(std::string(info.topic), std::string(expectedTopic));
            }

            TS_ASSERT_EQUALS(info.topicId, TopicId);
            TS_ASSERT_EQUALS(info.qos, CommonTestClient::transformQos(Qos));
            TS_ASSERT_EQUALS(info.retain, Retain);
            TS_ASSERT_EQUALS(info.msgLen, Data.size());
            TS_ASSERT(std::equal(Data.begin(), Data.end(), info.msg));
        });


    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, MsgId, Data, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    TS_ASSERT(state.m_messageReported);
    TS_ASSERT(state.m_nextOutput.empty());

    static const char* Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, MsgId + 1, Data, Qos, Retain, false);
    expectedTopic = Topic;
    TS_ASSERT(!state.m_messageReported);
    dataFromGw(*client, publishMsg, "PUBLISH");
    TS_ASSERT(state.m_messageReported);
    TS_ASSERT(state.m_nextOutput.empty());
}

void ClientBasic::test25()
{
    DataProcessor dataProc;
    typedef TestBasicState Test25State;

    Test25State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto Qos = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty()); // Duplicated mustn't be reported

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    expectedMsgId = MsgId + 1;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
}

void ClientBasic::test26()
{
    DataProcessor dataProc;
    typedef TestBasicState Test26State;

    Test26State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto Qos = mqttsn::protocol::field::QosType::ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty()); // Duplicate not reported

    clearState(state);
    ++expectedMsgId;
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
}


