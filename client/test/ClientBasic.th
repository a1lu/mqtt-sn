//
// Copyright 2016 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#include "comms/comms.h"
#include "mqttsn/client/common.h"
#include "client.h"

CC_DISABLE_WARNINGS()
#include "cxxtest/TestSuite.h"
CC_ENABLE_WARNINGS()

#include "CommonTestClient.h"
#include "DataProcessor.h"

class ClientBasic : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();
    void test26();

private:
    typedef DataProcessor::DataBuf DataBuf;

    typedef DataProcessor::AdvertiseMsg AdvertiseMsg;
    typedef DataProcessor::SearchgwMsg SearchgwMsg;
    typedef DataProcessor::GwinfoMsg GwinfoMsg;
    typedef DataProcessor::ConnectMsg ConnectMsg;
    typedef DataProcessor::ConnackMsg ConnackMsg;
    typedef DataProcessor::WilltopicreqMsg WilltopicreqMsg;
    typedef DataProcessor::WilltopicMsg WilltopicMsg;
    typedef DataProcessor::WillmsgreqMsg WillmsgreqMsg;
    typedef DataProcessor::WillmsgMsg WillmsgMsg;
    typedef DataProcessor::RegisterMsg RegisterMsg;
    typedef DataProcessor::RegackMsg RegackMsg;
    typedef DataProcessor::PublishMsg PublishMsg;
    typedef DataProcessor::PubackMsg PubackMsg;
    typedef DataProcessor::PubrecMsg PubrecMsg;
    typedef DataProcessor::PubrelMsg PubrelMsg;
    typedef DataProcessor::PubcompMsg PubcompMsg;
    typedef DataProcessor::PingreqMsg PingreqMsg;
    typedef DataProcessor::PingrespMsg PingrespMsg;
    typedef DataProcessor::DisconnectMsg DisconnectMsg;

    static const unsigned DefaultAdvertisePeriod = 5 * 60 * 1000;
    static const unsigned DefaultRetryTimeout = 5 * 1000;
    static const unsigned DefaultRetryCount = 3;
    static const unsigned char DefaultBroadcastRadius = 0;
    static const unsigned short DefaultKeepAlive = 60;

    typedef std::vector<std::uint8_t> DataSeq;

    struct TestBasicState
    {
        unsigned m_nextRequestedTicks = 0;
        unsigned m_nextElapsedTicks = 0;
        DataSeq m_nextOutput;
        bool m_broadcast;
    };

    template <typename TState>
    void clearState(TState& state)
    {
        state = TState();
    }

    void sendData(CommonTestClient& client, const DataBuf& buf, const std::string& msg)
    {
        if (!msg.empty()) {
            TS_TRACE("--> " + msg);
        }
        client.inputData(&buf[0], buf.size());
    }

    typedef CommonTestClient::Ptr ClientPtr;
    ClientPtr allocClient(TestBasicState* state = nullptr, DataProcessor* dataProc = nullptr)
    {
        auto ptr = CommonTestClient::alloc();
        assert(ptr);
        ptr->setGwAdvertisePeriod(DefaultAdvertisePeriod);
        ptr->setRetryPeriod(DefaultRetryTimeout);
        ptr->setRetryCount(DefaultRetryCount);
        ptr->setBroadcastRadius(DefaultBroadcastRadius);
        ptr->setConnectionStatusReportCallback(
            [](MqttsnConnectionStatus val)
            {
                TS_TRACE("Connect status reported: " + std::to_string((int)val));
            });
        ptr->setPublishCompleteCallback(
            [](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Publish complete with status: " + std::to_string((int)val));
            });
        ptr->setMessageReportCallback(
            [](const MqttsnMessageInfo& msgInfo)
            {
                TS_TRACE(std::string("Received message with topic ") + msgInfo.topic);
            });


        if (state != nullptr) {
            ptr->setProgramNextTickCallback(
                [state](unsigned duration)
                {
                    state->m_nextRequestedTicks = duration;
                });

            ptr->setCancelNextTickCallback(
                [state]() -> unsigned
                {
                    return state->m_nextElapsedTicks;
                });

            ptr->setSendDataCallback(
                [state](const std::uint8_t* buf, unsigned bufLen, bool broadcast)
                {
                    assert(state->m_nextOutput.empty());
//                    TS_TRACE("Sending " + std::to_string(bufLen) + " bytes; broadcast=" + std::to_string(broadcast));
                    state->m_nextOutput.insert(state->m_nextOutput.end(), buf, buf + bufLen);
                    state->m_broadcast = broadcast;
                });

        }

        if (dataProc != nullptr)
        {
            dataProc->setSearchgwMsgReportCallback(
                [](const SearchgwMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- SEARCHGW");
                });

            dataProc->setConnectMsgReportCallback(
                [](const ConnectMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- CONNECT");
                });

            dataProc->setWilltopicMsgReportCallback(
                [](const WilltopicMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLTOPIC");
                });

            dataProc->setWillmsgMsgReportCallback(
                [](const WillmsgMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLMSG");
                });

            dataProc->setRegisterMsgReportCallback(
                [](const RegisterMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGISTER");
                });

            dataProc->setRegackMsgReportCallback(
                [](const RegackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGACK");
                });

            dataProc->setPublishMsgReportCallback(
                [](const PublishMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBLISH");
                });

            dataProc->setPubackMsgReportCallback(
                [](const PubackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBACK");
                });

            dataProc->setPubrecMsgReportCallback(
                [](const PubrecMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREC");
                });

            dataProc->setPubrelMsgReportCallback(
                [](const PubrelMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREL");
                });

            dataProc->setPubcompMsgReportCallback(
                [](const PubcompMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBCOMP");
                });

            dataProc->setPingreqMsgReportCallback(
                [](const PingreqMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGREQ");
                });

            dataProc->setPingrespMsgReportCallback(
                [](const PingrespMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGRESP");
                });

        }

        return std::move(ptr);
    }

    void doGwInfo(CommonTestClient& client, DataProcessor& dataProc, TestBasicState& state)
    {
        bool searchgwSent = false;
        bool gwStatusReported = false;
        static const std::uint8_t GwId = 5U;
        auto oldGwStatusReportCb = client.setGwStatusReportCallback(
            [&](unsigned short gwId, MqttsnGwStatus status)
            {
                TS_ASSERT_EQUALS(gwId, GwId);
                TS_ASSERT_EQUALS(status, MqttsnGwStatus_Available);
                gwStatusReported = true;
                TS_TRACE("GW reported");
            });

        auto oldSearchgwMsgReportCb = dataProc.setSearchgwMsgReportCallback(
            [&searchgwSent](const SearchgwMsg& msg)
            {
                TS_TRACE("<-- SEARCHGW");
                auto& fields = msg.fields();
                auto& radiusField = std::get<SearchgwMsg::FieldIdx_radus>(fields);
                TS_ASSERT_EQUALS(radiusField.value(), DefaultBroadcastRadius);
                searchgwSent = true;
            });

        TS_ASSERT(!state.m_nextOutput.empty());
        TS_ASSERT(state.m_broadcast);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

        dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());
        TS_ASSERT(searchgwSent);

        auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
        TS_ASSERT(!gwInfoData.empty());

        state.m_nextElapsedTicks = 1 * 1000;
        sendData(client, gwInfoData, "GWINFO");
        TS_ASSERT(gwStatusReported);

        dataProc.setSearchgwMsgReportCallback(std::move(oldSearchgwMsgReportCb));
        client.setGwStatusReportCallback(std::move(oldGwStatusReportCb));
    }

    void doConnect(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        bool hasWill = false)
    {
        bool connectMsgSent = false;
        bool willTopicSent = false;
        bool willMsgSent = false;
        bool connectComplete = true;

        static const std::string ClientId = "test_client";
        static const std::string WillTopic("/this/is/will");
        static const std::vector<std::uint8_t> WillData{
            0x1, 0x2, 0x3, 0x4
        };
        static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
        static const bool WillRetain = false;

        static const auto WillInfoCreateFunc =
            []() -> MqttsnWillInfo
            {
                auto willInfo = MqttsnWillInfo();
                willInfo.topic = WillTopic.c_str();
                willInfo.msg = &WillData[0];
                willInfo.msgLen = WillData.size();
                willInfo.qos = WillQos;
                willInfo.retain = WillRetain;
                return willInfo;
            };

        static const MqttsnWillInfo WillInfo = WillInfoCreateFunc();

        auto oldConnectMsgReportCb = dataProc.setConnectMsgReportCallback(
            [&](const ConnectMsg& msg)
            {
                TS_TRACE("<-- CONNECT");
                connectMsgSent = true;
                auto& fields = msg.fields();
                auto& flagsField = std::get<ConnectMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& midFlags = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                auto& protocolIdField = std::get<ConnectMsg::FieldIdx_protocolId>(fields);
                auto& durationField = std::get<ConnectMsg::FieldIdx_duration>(fields);
                auto& clientIdField = std::get<ConnectMsg::FieldIdx_clientId>(fields);

                TS_ASSERT(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_cleanSession));
                TS_ASSERT_EQUALS(hasWill, midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_will));
                TS_ASSERT_EQUALS(protocolIdField.value(), 1);
                TS_ASSERT_EQUALS(durationField.value(), DefaultKeepAlive);
                TS_ASSERT_EQUALS(clientIdField.value(), ClientId);
            });

        auto oldWillTopicReportCb = dataProc.setWilltopicMsgReportCallback(
            [&](const WilltopicMsg& msg)
            {
                TS_TRACE("<-- WILLTOPIC");
                willTopicSent = true;
                auto& fields = msg.fields();
                auto& flagsField = std::get<WilltopicMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                auto& topicField = std::get<WilltopicMsg::FieldIdx_willTopic>(fields);

                TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), WillRetain);
                TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), WillQos);
                TS_ASSERT_EQUALS(topicField.value(), WillTopic);
            });

        auto oldWillMsgReportCb = dataProc.setWillmsgMsgReportCallback(
            [&](const WillmsgMsg& msg)
            {
                TS_TRACE("<-- WILLMSG");
                willMsgSent = true;
                auto& fields = msg.fields();
                auto& willMsgField = std::get<WillmsgMsg::FieldIdx_willMsg>(fields);

                TS_ASSERT_EQUALS(willMsgField.value(), WillData);
            });

        TS_TRACE("Connecting...");

        auto oldConnectStatusReportCb = client.setConnectionStatusReportCallback(
            [&](MqttsnConnectionStatus val)
            {
                // First connect is expected to be timed out
                TS_TRACE("Connect status reported: " + std::to_string((int)val));
                TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_Connected);
                connectComplete = true;
            });

        state.m_nextElapsedTicks = 0;

        const MqttsnWillInfo* willInfo = nullptr;
        if (hasWill) {
            willInfo = &WillInfo;
        }
        auto result =
            client.connect(ClientId.c_str(), DefaultKeepAlive, true, willInfo);

        TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

        TS_ASSERT(!state.m_nextOutput.empty());
        TS_ASSERT(!state.m_broadcast);
        dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

        TS_ASSERT(connectMsgSent);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

        clearState(state);

        if (hasWill) {
            auto willTopicReq = dataProc.prepareWilltopicreqMsg();
            sendData(client, willTopicReq, "WILLTOPICREQ");

            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(willTopicSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

            clearState(state);

            auto willMsgReq = dataProc.prepareWillmsgreqMsg();
            sendData(client, willMsgReq, "WILLMSGREQ");

            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(willMsgSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

            clearState(state);
        }

        auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
        sendData(client, connackMsg, "CONNACK");
        TS_ASSERT(connectComplete);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

        dataProc.setConnectMsgReportCallback(std::move(oldConnectMsgReportCb));
        dataProc.setWilltopicMsgReportCallback(std::move(oldWillTopicReportCb));
        dataProc.setWillmsgMsgReportCallback(std::move(oldWillMsgReportCb));
        client.setConnectionStatusReportCallback(std::move(oldConnectStatusReportCb));
    }

    void startClient(CommonTestClient& client)
    {
        bool result = client.start();
        TS_ASSERT(result);
    }

    void doTopicRegister(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        const std::string& topic,
        MqttsnTopicId topicId,
        std::uint16_t msgId)
    {
        bool regackSent = false;
        auto oldCb = dataProc.setRegackMsgReportCallback(
            [&](const RegackMsg& msg)
            {
                regackSent = true;
                TS_TRACE("<-- REGACK");

                auto& fields = msg.fields();
                auto& topicIdField = std::get<RegackMsg::FieldIdx_topicId>(fields);
                auto& msgIdField = std::get<RegackMsg::FieldIdx_msgId>(fields);
                auto& retCodeField = std::get<RegackMsg::FieldIdx_returnCode>(fields);

                TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                TS_ASSERT_EQUALS(retCodeField.value(), mqttsn::protocol::field::ReturnCodeVal_Accepted);
            });


        clearState(state);
        auto registerMsg = dataProc.prepareRegisterMsg(topicId, msgId, topic);
        state.m_nextElapsedTicks = 1000;
        sendData(client, registerMsg, "REGISTER");

        TS_ASSERT(!state.m_nextOutput.empty());
        TS_ASSERT(!state.m_broadcast);
        dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

        TS_ASSERT(regackSent);

        dataProc.setRegackMsgReportCallback(std::move(oldCb));
    }
};

void ClientBasic::test1()
{
    auto client = allocClient();
    static_cast<void>(client);
}

void ClientBasic::test2()
{
    DataProcessor dataProc;
    struct Test2State : public TestBasicState
    {
        bool m_searchgwSent = false;
    };

    Test2State state;

    auto client = allocClient(&state, &dataProc);

    dataProc.setSearchgwMsgReportCallback(
        [&state](const SearchgwMsg& msg)
        {
            TS_TRACE("<-- SEARCHGW");
            auto& fields = msg.fields();
            auto& radiusField = std::get<SearchgwMsg::FieldIdx_radus>(fields);
            TS_ASSERT_EQUALS(radiusField.value(), DefaultBroadcastRadius);
            state.m_searchgwSent = true;
        });

    auto checkSearchgwMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(state.m_broadcast);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());
            TS_ASSERT(state.m_searchgwSent);
        };

    startClient(*client);

    TS_TRACE("Started");
    checkSearchgwMessage();
    clearState(state);
    TS_TRACE("Tick");
    client->tick(DefaultRetryTimeout);
    checkSearchgwMessage();
    clearState(state);

    MqttsnGwStatus reportedGwStatus = MqttsnGwStatus_TimedOut;
    std::uint8_t reportedGwId = 0U;
    bool gwStatusReported = false;
    client->setGwStatusReportCallback(
        [&](unsigned short gwId, MqttsnGwStatus status)
        {
            reportedGwId = gwId;
            reportedGwStatus = status;
            gwStatusReported = true;
        });

    static const std::uint8_t GwId = 5U;
    auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
    TS_ASSERT(!gwInfoData.empty());

    assert(state.m_nextRequestedTicks == 0U);
    state.m_nextElapsedTicks = 1 * 1000;
    sendData(*client, gwInfoData, "GWINFO");

    TS_ASSERT(gwStatusReported);
    TS_ASSERT_EQUALS(reportedGwId, GwId);
    TS_ASSERT_EQUALS(reportedGwStatus, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultAdvertisePeriod);

    clearState(state);
    gwStatusReported = false;
    client->tick(DefaultAdvertisePeriod);
    TS_ASSERT(gwStatusReported);
    TS_ASSERT_EQUALS(reportedGwId, GwId);
    TS_ASSERT_EQUALS(reportedGwStatus, MqttsnGwStatus_TimedOut);
    checkSearchgwMessage();

    clearState(state);
    auto advertiseData = dataProc.prepareAdvertiseMsg(GwId, (DefaultAdvertisePeriod / 1000) + 1);
    TS_ASSERT(!advertiseData.empty());
    state.m_nextElapsedTicks = 1 * 1000;

    sendData(*client, advertiseData, "ADVERTISE");

    TS_ASSERT(gwStatusReported);
    TS_ASSERT_EQUALS(reportedGwId, GwId);
    TS_ASSERT_EQUALS(reportedGwStatus, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultAdvertisePeriod  + 1000);

    clearState(state);
    gwStatusReported = false;
    client->tick(DefaultAdvertisePeriod  + 1000);
    TS_ASSERT(gwStatusReported);
    TS_ASSERT_EQUALS(reportedGwId, GwId);
    TS_ASSERT_EQUALS(reportedGwStatus, MqttsnGwStatus_TimedOut);
    checkSearchgwMessage();
}

void ClientBasic::test3()
{
    // Connect without will
    DataProcessor dataProc;
    struct Test3State : public TestBasicState
    {
        bool m_connectMsgSent = false;
        MqttsnConnectionStatus m_connectionStatus = MqttsnConnectionStatus_Invalid;
    };

    Test3State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    dataProc.setConnectMsgReportCallback(
        [&](const ConnectMsg& msg)
        {
            TS_TRACE("<-- CONNECT");
            state.m_connectMsgSent = true;
            auto& fields = msg.fields();
            auto& flagsField = std::get<ConnectMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlags = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& protocolIdField = std::get<ConnectMsg::FieldIdx_protocolId>(fields);
            auto& durationField = std::get<ConnectMsg::FieldIdx_duration>(fields);
            auto& clientIdField = std::get<ConnectMsg::FieldIdx_clientId>(fields);

            TS_ASSERT(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_cleanSession));
            TS_ASSERT(!(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_will)));
            TS_ASSERT_EQUALS(protocolIdField.value(), 1);
            TS_ASSERT_EQUALS(durationField.value(), KeepAlive);
            TS_ASSERT_EQUALS(clientIdField.value(), ClientId);
        });

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            // First connect is expected to be timed out
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_Timeout);

            client->setConnectionStatusReportCallback(
                [&](MqttsnConnectionStatus val2)
                {
                    TS_TRACE("Connect status reported: " + std::to_string((int)val2));
                    TS_ASSERT_EQUALS(val2, MqttsnConnectionStatus_Connected);
                    state.m_connectionStatus = val2;
                });

            TS_TRACE("Reconnecting...");
            auto result2 =
                client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

            TS_ASSERT_EQUALS(result2, MqttsnErrorCode_Success);

        });

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkConnectMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_connectMsgSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkConnectMessage();
    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    checkConnectMessage();

    nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    checkConnectMessage();

    nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);

    // Timeout and new connect attempt is expected here

    checkConnectMessage();
    clearState(state);
    auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, connackMsg, "CONNACK");

    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Connected);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, KeepAlive * 1000);
}

void ClientBasic::test4()
{
    // Connect with will
    DataProcessor dataProc;
    struct Test4State : public TestBasicState
    {
        bool m_connectMsgSent = false;
        bool m_willTopicSent = false;
        bool m_willMsgSent = false;
        bool m_connectComplete = false;
    };

    Test4State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;
    static const std::string WillTopic("/this/is/will");
    static const std::vector<std::uint8_t> WillData{
        0x1, 0x2, 0x3, 0x4
    };
    static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool WillRetain = false;

    dataProc.setConnectMsgReportCallback(
        [&](const ConnectMsg& msg)
        {
            TS_TRACE("<-- CONNECT");
            state.m_connectMsgSent = true;
            auto& fields = msg.fields();
            auto& flagsField = std::get<ConnectMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlags = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& protocolIdField = std::get<ConnectMsg::FieldIdx_protocolId>(fields);
            auto& durationField = std::get<ConnectMsg::FieldIdx_duration>(fields);
            auto& clientIdField = std::get<ConnectMsg::FieldIdx_clientId>(fields);

            TS_ASSERT(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_cleanSession));
            TS_ASSERT(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_will));
            TS_ASSERT_EQUALS(protocolIdField.value(), 1);
            TS_ASSERT_EQUALS(durationField.value(), KeepAlive);
            TS_ASSERT_EQUALS(clientIdField.value(), ClientId);
        });

    dataProc.setWilltopicMsgReportCallback(
        [&](const WilltopicMsg& msg)
        {
            TS_TRACE("<-- WILLTOPIC");
            state.m_willTopicSent = true;
            auto& fields = msg.fields();
            auto& flagsField = std::get<WilltopicMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& topicField = std::get<WilltopicMsg::FieldIdx_willTopic>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), WillRetain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), WillQos);
            TS_ASSERT_EQUALS(topicField.value(), WillTopic);
        });

    dataProc.setWillmsgMsgReportCallback(
        [&](const WillmsgMsg& msg)
        {
            TS_TRACE("<-- WILLMSG");
            state.m_willMsgSent = true;
            auto& fields = msg.fields();
            auto& willMsgField = std::get<WillmsgMsg::FieldIdx_willMsg>(fields);

            TS_ASSERT_EQUALS(willMsgField.value(), WillData);
        });

    TS_TRACE("Connecting...");
    auto willInfo = MqttsnWillInfo();
    willInfo.topic = WillTopic.c_str();
    willInfo.msg = &WillData[0];
    willInfo.msgLen = WillData.size();
    willInfo.qos = WillQos;
    willInfo.retain = WillRetain;

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            // First connect is expected to be timed out
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_Connected);
            state.m_connectComplete = true;
        });

    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, &willInfo);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkConnectMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_connectMsgSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkConnectMessage();
    clearState(state);

    // Send ack message, check ignored
    state.m_nextElapsedTicks = 1000;
    auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, connackMsg, "CONNACK");
    // Ack must be ignored
    TS_ASSERT(!state.m_connectComplete);
    TS_ASSERT(state.m_nextOutput.empty())

    auto willTopicReq = dataProc.prepareWilltopicreqMsg();
    sendData(*client, willTopicReq, "WILLTOPICREQ");

    auto checkWilltopicMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_willTopicSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkWilltopicMessage();
    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);

    client->tick(nextTick); // Timeout is expected, new connect attempt

    checkConnectMessage();
    clearState(state);

    state.m_nextElapsedTicks = 1000;
    sendData(*client, willTopicReq, "WILLTOPICREQ");
    checkWilltopicMessage();
    clearState(state);

    auto checkWillmsgMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_willMsgSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    state.m_nextElapsedTicks = 1000;
    auto willMsgReq = dataProc.prepareWillmsgreqMsg();
    sendData(*client, willMsgReq, "WILLMSGREQ");
    checkWillmsgMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    sendData(*client, connackMsg, "CONNACK");

    // check connected
    TS_ASSERT(state.m_connectComplete);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, KeepAlive * 1000);
}

void ClientBasic::test5()
{
    DataProcessor dataProc;
    struct Test5State : public TestBasicState
    {
        bool m_pingReqSent = false;
        MqttsnConnectionStatus m_connectionStatus = MqttsnConnectionStatus_Invalid;
    };

    Test5State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            state.m_connectionStatus = val;
        });

    auto nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, DefaultKeepAlive * 1000);

    dataProc.setPingreqMsgReportCallback(
        [&](const PingreqMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- PINGREQ");
            state.m_pingReqSent = true;
        });

    auto checkPingreqMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pingReqSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    client->tick(nextTicks);
    checkPingreqMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingRespMsg = dataProc.preparePingrespMsg();
    sendData(*client, pingRespMsg, "PINGRESP");

    TS_ASSERT(state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);

    nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, DefaultKeepAlive * 1000);

    clearState(state);
    client->tick(nextTicks);
    checkPingreqMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkPingreqMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkPingreqMessage();

    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Invalid);
    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test6()
{
    DataProcessor dataProc;
    struct Test6State : public TestBasicState
    {
        bool m_pingRespSent = false;
        MqttsnConnectionStatus m_connectionStatus = MqttsnConnectionStatus_Invalid;
    };

    Test6State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            state.m_connectionStatus = val;
        });

    dataProc.setPingrespMsgReportCallback(
        [&](const PingrespMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- PINGRESP");
            state.m_pingRespSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingreqMsg = dataProc.preparePingreqMsg();
    sendData(*client, pingreqMsg, "PINGREQ");

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_pingRespSent);

    clearState(state);
    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Invalid);
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    sendData(*client, disconnectMsg, "DISCONNECT");
    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test7()
{
    DataProcessor dataProc;
    struct Test7State : public TestBasicState
    {
        bool m_disconnectSent = false;
        MqttsnConnectionStatus m_connectionStatus = MqttsnConnectionStatus_Invalid;
    };

    Test7State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            state.m_connectionStatus = val;
        });

    dataProc.setDisconnectMsgReportCallback(
        [&](const DisconnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- DISCONNECT");
            state.m_disconnectSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_disconnectSent);

    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Invalid);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    state.m_nextElapsedTicks = 1000;
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    sendData(*client, disconnectMsg, "DISCONNECT");

    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test8()
{
    DataProcessor dataProc;
    struct Test8State : public TestBasicState
    {
        bool m_disconnectSent = false;
        MqttsnConnectionStatus m_connectionStatus = MqttsnConnectionStatus_Invalid;
    };

    Test8State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            state.m_connectionStatus = val;
        });

    dataProc.setDisconnectMsgReportCallback(
        [&](const DisconnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- DISCONNECT");
            state.m_disconnectSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkDisconnectFunc =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(state.m_nextOutput);
            TS_ASSERT(state.m_disconnectSent);

            TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Invalid);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkDisconnectFunc();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkDisconnectFunc();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkDisconnectFunc();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);

    TS_ASSERT(state.m_nextOutput.empty());
    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test9()
{
    DataProcessor dataProc;
    struct Test9State : public TestBasicState
    {
        bool m_connectMsgSent = false;
        bool m_connectionStatusReported = false;
    };

    Test9State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    dataProc.setConnectMsgReportCallback(
        [&](const ConnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- CONNECT");
            state.m_connectMsgSent = true;
        });

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            // First connect is expected to be timed out
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_ConnectAborted);
            state.m_connectionStatusReported = true;
        });

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkConnectMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_connectMsgSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkConnectMessage();

    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    checkConnectMessage();

    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    TS_ASSERT(state.m_connectionStatusReported)
}

void ClientBasic::test10()
{
    DataProcessor dataProc;
    struct Test10State : public TestBasicState
    {
        bool m_disconnectSent = false;
        bool m_connectionStatusReported = false;
    };

    Test10State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_Disconnected);
            state.m_connectionStatusReported = val;
        });

    dataProc.setDisconnectMsgReportCallback(
        [&](const DisconnectMsg& msg)
        {
            static_cast<void>(msg);
            TS_TRACE("<-- DISCONNECT");
            state.m_disconnectSent = true;
        });

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_disconnectSent);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    state.m_nextElapsedTicks = 1000;
    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    TS_ASSERT(state.m_connectionStatusReported);
}

void ClientBasic::test11()
{
    DataProcessor dataProc;
    struct Test11State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test11State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_publishCompleteReported);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_publishSent);

}

void ClientBasic::test12()
{
    DataProcessor dataProc;
    struct Test12State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test12State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);

    static const MqttsnTopicId TopicId = 0x0123;
    static const MqttsnQoS Qos = MqttsnQoS_NoGwPublish;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
        });

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), MqttsnQoS_AtMostOnceDelivery, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);
    TS_ASSERT(!state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty());

    result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_publishCompleteReported);

    TS_ASSERT(!state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);
    dataProc.checkWrittenMsg(state.m_nextOutput);
    TS_ASSERT(state.m_publishSent);

}

void ClientBasic::test13()
{
    DataProcessor dataProc;
    struct Test13State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test13State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    bool mustBeDuplicate = false;
    std::uint16_t msgId = 0U;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    TS_ASSERT(!state.m_publishCompleteReported);
    checkPublishMessage();
    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);

    client->tick(nextTicks);
    mustBeDuplicate = true;
    checkPublishMessage();
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(!state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty()); // must be ignored

    clearState(state);
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
}

void ClientBasic::test14()
{
    DataProcessor dataProc;
    struct Test14State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test14State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_InvalidId);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            msgId = msgIdField.value();
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    TS_ASSERT(!state.m_publishCompleteReported);
    checkPublishMessage();
    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
}

void ClientBasic::test15()
{
    DataProcessor dataProc;
    struct Test15State : public TestBasicState
    {
        bool m_publishSent = false;
        bool m_pubrelSent = false;
        bool m_publishCompleteReported = false;
    };

    Test15State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    bool mustBeDuplicate = false;
    std::uint16_t msgId = 0U;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    dataProc.setPubrelMsgReportCallback(
        [&](const PubrelMsg& msg)
        {
            TS_TRACE("<-- PUBREL");
            state.m_pubrelSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubrelMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), msgId);
        });


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    auto checkPubrelMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubrelSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkPublishMessage();
    clearState(state);

    state.m_nextElapsedTicks = 2000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    sendData(*client, pubrecMsg, "PUBREC");

    TS_ASSERT(!state.m_publishCompleteReported);
    checkPubrelMessage();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);

    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);
    mustBeDuplicate = true;
    checkPublishMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrecMsg = dataProc.preparePubrecMsg(msgId);
    sendData(*client, pubrecMsg, "PUBREC");

    TS_ASSERT(!state.m_publishCompleteReported);
    checkPubrelMessage();

    clearState(state);
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    sendData(*client, pubcompMsg, "PUBCOMP");
    TS_ASSERT(state.m_publishCompleteReported);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test16()
{
    DataProcessor dataProc;
    struct Test16State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test16State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty());

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
    TS_ASSERT(state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    checkPublishMessage();
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000 - state.m_nextElapsedTicks);
}

void ClientBasic::test17()
{
    DataProcessor dataProc;
    struct Test17State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishCompleteReported = false;
    };

    Test17State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_NoResponse);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);

    checkRegisterMessage();
    TS_ASSERT(!state.m_publishCompleteReported);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    checkRegisterMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT(state.m_nextOutput.empty());
}

void ClientBasic::test18()
{
    DataProcessor dataProc;
    struct Test18State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test18State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(!state.m_publishCompleteReported);

    mustBeDuplicate = true;
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test19()
{
    DataProcessor dataProc;
    struct Test19State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test19State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_registerSent);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test20()
{
    DataProcessor dataProc;
    struct Test20State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test20State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_InvalidId);
            state.m_publishCompleteReported = true;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            msgId = msgIdField.value();
        });

    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    TS_ASSERT(!state.m_publishCompleteReported);
    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");
    TS_ASSERT(!state.m_publishCompleteReported);

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(!state.m_publishCompleteReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_publishCompleteReported);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test21()
{
    DataProcessor dataProc;
    struct Test21State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_publishSent = false;
        bool m_pubrelSent = false;
        MqttsnAsyncOpStatus m_publishCompleteStatus = MqttsnAsyncOpStatus_Invalid;
    };

    Test21State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            state.m_publishCompleteStatus = status;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic, topicNameField.value());
            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    static const MqttsnTopicId TopicId = 0x1234;
    bool mustBeDuplicate = false;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            msgId = msgIdField.value();

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    dataProc.setPubrelMsgReportCallback(
        [&](const PubrelMsg& msg)
        {
            TS_TRACE("<-- PUBREL");
            state.m_pubrelSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubrelMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            TS_TRACE("msgId=" + std::to_string(msgId));
        });


    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Aborted);

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    auto checkPubrelMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubrelSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    sendData(*client, pubrecMsg, "PUBREC");

    checkPubrelMessage();
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    TS_ASSERT_DIFFERS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Aborted);
    client->cancel();
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Aborted);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrecMsg = dataProc.preparePubrecMsg(msgId);
    sendData(*client, pubrecMsg, "PUBREC");
    checkPubrelMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    sendData(*client, pubcompMsg, "PUBCOMP");
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test22()
{
    DataProcessor dataProc;
    struct Test22State : public TestBasicState
    {
        bool m_regackSent = false;
        bool m_publishSent = false;
        bool m_publishCompleteReported = false;
    };

    Test22State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t RegMsgId = 0x1234;
    static const MqttsnTopicId TopicId = 0x2222;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    dataProc.setRegackMsgReportCallback(
        [&](const RegackMsg& msg)
        {
            TS_TRACE("<-- REGACK");
            state.m_regackSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegackMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegackMsg::FieldIdx_msgId>(fields);
            auto& retCodeField = std::get<RegackMsg::FieldIdx_returnCode>(fields);

            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(msgIdField.value(), RegMsgId);
            TS_ASSERT_EQUALS(retCodeField.value(), mqttsn::protocol::field::ReturnCodeVal_Accepted);
        });

     dataProc.setPublishMsgReportCallback(
         [&](const PublishMsg& msg)
         {
             TS_TRACE("<-- PUBLISH");
             state.m_publishSent = true;

             auto& fields = msg.fields();
             auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
             auto& flagsMembers = flagsField.value();
             auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
             auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
             auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
             auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
             auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
             auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

             TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
             TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), Qos);
             TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), false);
             TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
             TS_ASSERT_EQUALS(dataField.value(), Data);

             TS_TRACE("msgId=" + std::to_string(msgIdField.value()));
         });


    clearState(state);
    auto registerMsg = dataProc.prepareRegisterMsg(TopicId, RegMsgId, Topic);
    state.m_nextElapsedTicks = 1000;
    sendData(*client, registerMsg, "REGISTER");

    auto checkRegackMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_regackSent);
        };

    checkRegackMessage();

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            TS_ASSERT_EQUALS(status, MqttsnAsyncOpStatus_Successful);
            state.m_publishCompleteReported = true;
        });

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    checkPublishMessage();
    TS_ASSERT(state.m_publishCompleteReported);
}

void ClientBasic::test23()
{
    DataProcessor dataProc;
    struct Test23State : public TestBasicState
    {
        bool m_registerSent = false;
        bool m_regackSent = false;
        bool m_publishSent = false;
        bool m_pubrelSent = false;
        MqttsnAsyncOpStatus m_publishCompleteStatus = MqttsnAsyncOpStatus_Invalid;
    };

    Test23State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic1("this/is/topic1");
    static const std::string Topic2("this/is/topic2");
    static const MqttsnTopicId Topic1Id = 0x1234;
    static const MqttsnTopicId Topic2Id = 0x4321;
    static const std::uint16_t RegMsgId = 0x2222;
    static const MqttsnQoS Qos1 = MqttsnQoS_ExactlyOnceDelivery;
    static const MqttsnQoS Qos2 = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setPublishCompleteCallback(
        [&](MqttsnAsyncOpStatus status)
        {
            TS_TRACE("Publish complete with status: " + std::to_string(status));
            state.m_publishCompleteStatus = status;
        });

    std::uint16_t msgId = 0U;
    dataProc.setRegisterMsgReportCallback(
        [&](const RegisterMsg& msg)
        {
            TS_TRACE("<-- REGISTER");
            state.m_registerSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
            auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

            TS_ASSERT_EQUALS(0U, topicIdField.value());
            msgId = msgIdField.value();
            TS_ASSERT_EQUALS(Topic1, topicNameField.value());
            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    dataProc.setRegackMsgReportCallback(
        [&](const RegackMsg& msg)
        {
            TS_TRACE("<-- REGACK");
            state.m_regackSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<RegackMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<RegackMsg::FieldIdx_msgId>(fields);
            auto& retCodeField = std::get<RegackMsg::FieldIdx_returnCode>(fields);

            TS_ASSERT_EQUALS(topicIdField.value(), Topic2Id);
            TS_ASSERT_EQUALS(msgIdField.value(), RegMsgId);
            TS_ASSERT_EQUALS(retCodeField.value(), mqttsn::protocol::field::ReturnCodeVal_Accepted);
        });

    bool mustBeDuplicate = false;
    MqttsnTopicId pubTopic = 0;
    MqttsnQoS pubQos = MqttsnQoS_NoGwPublish;
    dataProc.setPublishMsgReportCallback(
        [&](const PublishMsg& msg)
        {
            TS_TRACE("<-- PUBLISH");
            state.m_publishSent = true;

            auto& fields = msg.fields();
            auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
            auto& flagsMembers = flagsField.value();
            auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
            auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
            auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
            auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
            auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

            TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), Retain);
            TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), pubQos);
            TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), mustBeDuplicate);
            TS_ASSERT_EQUALS(topicIdField.value(), pubTopic);
            TS_ASSERT_EQUALS(dataField.value(), Data);
            msgId = msgIdField.value();

            if (mustBeDuplicate) {
                TS_ASSERT_EQUALS(msgId, msgIdField.value());
            }

            TS_TRACE("msgId=" + std::to_string(msgId));
        });

    dataProc.setPubrelMsgReportCallback(
        [&](const PubrelMsg& msg)
        {
            TS_TRACE("<-- PUBREL");
            state.m_pubrelSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubrelMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            TS_TRACE("msgId=" + std::to_string(msgId));
        });


    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic1, &Data[0], Data.size(), Qos1, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto checkRegisterMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_registerSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };

    checkRegisterMessage();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(Topic1Id, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, regackMsg, "REGACK");

    auto checkPublishMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_publishSent);
        };

    pubTopic = Topic1Id;
    pubQos = Qos1;
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    doTopicRegister(*client, dataProc, state, Topic2, Topic2Id, RegMsgId);

    auto checkPubrelMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubrelSent);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        };


    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    sendData(*client, pubrecMsg, "PUBREC");

    checkPubrelMessage();
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    sendData(*client, pubcompMsg, "PUBCOMP");
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->publish(Topic2, &Data[0], Data.size(), Qos2, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    pubTopic = Topic2Id;
    pubQos = Qos2;
    checkPublishMessage();
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(Topic2Id, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    sendData(*client, pubackMsg, "PUBACK");
    TS_ASSERT_EQUALS(state.m_publishCompleteStatus, MqttsnAsyncOpStatus_Successful);
}

void ClientBasic::test24()
{
    DataProcessor dataProc;
    struct Test24State : public TestBasicState
    {
        bool m_messageReported = false;
    };

    Test24State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x1234;
    static const std::uint16_t MsgId = 0x5555;
    static const auto Qos = mqttsn::protocol::field::QosType::AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    const char* expectedTopic = nullptr;
    client->setMessageReportCallback(
        [&](const MqttsnMessageInfo& info)
        {
            state.m_messageReported = true;

            if (expectedTopic == nullptr) {
                TS_TRACE("Message reported with topic ID " + std::to_string(info.topicId));
                TS_ASSERT_EQUALS(info.topic, expectedTopic);
            }
            else {
                TS_TRACE("Message reported with topic " + std::string(info.topic));
                TS_ASSERT_EQUALS(std::string(info.topic), std::string(expectedTopic));
            }

            TS_ASSERT_EQUALS(info.topicId, TopicId);
            TS_ASSERT_EQUALS(info.qos, CommonTestClient::transformQos(Qos));
            TS_ASSERT_EQUALS(info.retain, Retain);
            TS_ASSERT_EQUALS(info.msgLen, Data.size());
            TS_ASSERT(std::equal(Data.begin(), Data.end(), info.msg));
        });


    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, MsgId, Data, Qos, Retain, false);
    sendData(*client, publishMsg, "PUBLISH");
    TS_ASSERT(state.m_messageReported);
    TS_ASSERT(state.m_nextOutput.empty());

    static const char* Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, MsgId + 1, Data, Qos, Retain, false);
    expectedTopic = Topic;
    TS_ASSERT(!state.m_messageReported);
    sendData(*client, publishMsg, "PUBLISH");
    TS_ASSERT(state.m_messageReported);
    TS_ASSERT(state.m_nextOutput.empty());
}

void ClientBasic::test25()
{
    DataProcessor dataProc;
    struct Test25State : public TestBasicState
    {
        bool m_messageReported = false;
        bool m_pubackSent = false;
    };

    Test25State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto Qos = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setMessageReportCallback(
        [&](const MqttsnMessageInfo& info)
        {
            state.m_messageReported = true;
            TS_TRACE("Message reported with topic " + std::string(info.topic));
            TS_ASSERT_EQUALS(std::string(info.topic), Topic);

            TS_ASSERT_EQUALS(info.topicId, TopicId);
            TS_ASSERT_EQUALS(info.qos, CommonTestClient::transformQos(Qos));
            TS_ASSERT_EQUALS(info.retain, Retain);
            TS_ASSERT_EQUALS(info.msgLen, Data.size());
            TS_ASSERT(std::equal(Data.begin(), Data.end(), info.msg));
        });

    std::uint16_t expectedMsgId = 0;
    dataProc.setPubackMsgReportCallback(
        [&](const PubackMsg& msg)
        {
            TS_TRACE("<-- PUBACK");
            state.m_pubackSent = true;

            auto& fields = msg.fields();
            auto& topicIdField = std::get<PubackMsg::FieldIdx_topicId>(fields);
            auto& msgIdField = std::get<PubackMsg::FieldIdx_msgId>(fields);
            auto& retCodeField = std::get<PubackMsg::FieldIdx_returnCode>(fields);

            TS_ASSERT_EQUALS(topicIdField.value(), TopicId);
            TS_ASSERT_EQUALS(msgIdField.value(), expectedMsgId);
            TS_ASSERT_EQUALS(retCodeField.value(), mqttsn::protocol::field::ReturnCodeVal_Accepted);
        });


    auto checkPubackMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubackSent);
        };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, false);
    sendData(*client, publishMsg, "PUBLISH");
    checkPubackMessage();
    TS_ASSERT(state.m_messageReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    sendData(*client, publishMsg, "PUBLISH");
    checkPubackMessage();
    TS_ASSERT(!state.m_messageReported); // Duplicated mustn't be reported

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    expectedMsgId = MsgId + 1;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    sendData(*client, publishMsg, "PUBLISH");
    checkPubackMessage();
    TS_ASSERT(state.m_messageReported);
}

void ClientBasic::test26()
{
    DataProcessor dataProc;
    struct Test26State : public TestBasicState
    {
        bool m_messageReported = false;
        bool m_pubrecSent = false;
        bool m_pubcompSent = false;
    };

    Test26State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto Qos = mqttsn::protocol::field::QosType::ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    client->setMessageReportCallback(
        [&](const MqttsnMessageInfo& info)
        {
            state.m_messageReported = true;
            TS_TRACE("Message reported with topic " + std::string(info.topic));
            TS_ASSERT_EQUALS(std::string(info.topic), Topic);

            TS_ASSERT_EQUALS(info.topicId, TopicId);
            TS_ASSERT_EQUALS(info.qos, CommonTestClient::transformQos(Qos));
            TS_ASSERT_EQUALS(info.retain, Retain);
            TS_ASSERT_EQUALS(info.msgLen, Data.size());
            TS_ASSERT(std::equal(Data.begin(), Data.end(), info.msg));
        });

    std::uint16_t expectedMsgId = 0;
    dataProc.setPubrecMsgReportCallback(
        [&](const PubrecMsg& msg)
        {
            TS_TRACE("<-- PUBREC");
            state.m_pubrecSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubrecMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), expectedMsgId);
        });

    dataProc.setPubcompMsgReportCallback(
        [&](const PubcompMsg& msg)
        {
            TS_TRACE("<-- PUBCOMP");
            state.m_pubcompSent = true;

            auto& fields = msg.fields();
            auto& msgIdField = std::get<PubcompMsg::FieldIdx_msgId>(fields);

            TS_ASSERT_EQUALS(msgIdField.value(), expectedMsgId);
        });


    auto checkPubrecMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubrecSent);
        };

    auto checkPubcompMessage =
        [&]()
        {
            TS_ASSERT(!state.m_nextOutput.empty());
            TS_ASSERT(!state.m_broadcast);
            dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());

            TS_ASSERT(state.m_pubcompSent);
        };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, false);
    sendData(*client, publishMsg, "PUBLISH");
    checkPubrecMessage();
    TS_ASSERT(!state.m_messageReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    sendData(*client, pubrelMsg, "PUBREL");
    checkPubcompMessage();
    TS_ASSERT(state.m_messageReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    sendData(*client, publishMsg, "PUBLISH");
    checkPubrecMessage();
    TS_ASSERT(!state.m_messageReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    sendData(*client, pubrelMsg, "PUBREL");
    checkPubcompMessage();
    TS_ASSERT(!state.m_messageReported); // Duplicate not reported

    clearState(state);
    ++expectedMsgId;
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, Qos, Retain, true);
    sendData(*client, publishMsg, "PUBLISH");
    checkPubrecMessage();
    TS_ASSERT(!state.m_messageReported);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    sendData(*client, pubrelMsg, "PUBREL");
    checkPubcompMessage();
    TS_ASSERT(state.m_messageReported);
}


