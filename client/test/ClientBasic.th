//
// Copyright 2016 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <list>
#include <utility>

#include "comms/comms.h"
#include "mqttsn/client/common.h"
#include "client.h"

CC_DISABLE_WARNINGS()
#include "cxxtest/TestSuite.h"
CC_ENABLE_WARNINGS()

#include "CommonTestClient.h"
#include "DataProcessor.h"

class ClientBasic : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();
    void test26();
    void test27();

private:
    typedef DataProcessor::DataBuf DataBuf;

    typedef DataProcessor::AdvertiseMsg AdvertiseMsg;
    typedef DataProcessor::SearchgwMsg SearchgwMsg;
    typedef DataProcessor::GwinfoMsg GwinfoMsg;
    typedef DataProcessor::ConnectMsg ConnectMsg;
    typedef DataProcessor::ConnackMsg ConnackMsg;
    typedef DataProcessor::WilltopicreqMsg WilltopicreqMsg;
    typedef DataProcessor::WilltopicMsg WilltopicMsg;
    typedef DataProcessor::WillmsgreqMsg WillmsgreqMsg;
    typedef DataProcessor::WillmsgMsg WillmsgMsg;
    typedef DataProcessor::RegisterMsg RegisterMsg;
    typedef DataProcessor::RegackMsg RegackMsg;
    typedef DataProcessor::PublishMsg PublishMsg;
    typedef DataProcessor::PubackMsg PubackMsg;
    typedef DataProcessor::PubrecMsg PubrecMsg;
    typedef DataProcessor::PubrelMsg PubrelMsg;
    typedef DataProcessor::PubcompMsg PubcompMsg;
    typedef DataProcessor::SubscribeMsg SubscribeMsg;
    typedef DataProcessor::PingreqMsg PingreqMsg;
    typedef DataProcessor::PingrespMsg PingrespMsg;
    typedef DataProcessor::DisconnectMsg DisconnectMsg;

    typedef mqttsn::protocol::field::TopicIdTypeVal TopicIdTypeVal;

    static const unsigned DefaultAdvertisePeriod = 5 * 60 * 1000;
    static const unsigned DefaultRetryTimeout = 5 * 1000;
    static const unsigned DefaultRetryCount = 3;
    static const unsigned char DefaultBroadcastRadius = 0;
    static const unsigned short DefaultKeepAlive = 60;

    typedef std::vector<std::uint8_t> DataSeq;

    struct ReportedMsgInfo
    {
        ReportedMsgInfo(const MqttsnMessageInfo& info)
          : m_topic((info.topic != nullptr) ? info.topic : std::string()),
            m_topicId(info.topicId),
            m_data(info.msg, info.msg + info.msgLen),
            m_qos(info.qos),
            m_retain(info.retain)
        {
        }

        std::string m_topic;
        MqttsnTopicId m_topicId = 0;
        std::vector<std::uint8_t> m_data;
        MqttsnQoS m_qos = MqttsnQoS_NoGwPublish;
        bool m_retain = false;
    };

    struct ReportedGwInfo
    {
        ReportedGwInfo(std::uint16_t id, MqttsnGwStatus status)
          : m_id(id),
            m_status(status)
        {
        }

        unsigned short m_id = 0U;
        MqttsnGwStatus m_status = MqttsnGwStatus_Invalid;
    };

    struct TestBasicState
    {
        unsigned m_nextRequestedTicks = 0;
        unsigned m_nextElapsedTicks = 0;
        DataSeq m_nextOutput;
        bool m_broadcast;
        std::list<ReportedMsgInfo> m_reportedMsgs;
        std::list<ReportedGwInfo> m_reportedGws;
        std::list<MqttsnConnectionStatus> m_reportedConnStatuses;
        std::list<MqttsnAsyncOpStatus> m_reportedPublishes;
        std::list<std::pair<MqttsnAsyncOpStatus, MqttsnQoS> > m_reportedSubsribes;
    };

    template <typename TState>
    void clearState(TState& state)
    {
        state = TState();
    }

    void dataFromGw(CommonTestClient& client, const DataBuf& buf, const std::string& msg)
    {
        if (!msg.empty()) {
            TS_TRACE("--> " + msg);
        }
        client.inputData(&buf[0], buf.size());
    }

    typedef CommonTestClient::Ptr ClientPtr;
    ClientPtr allocClient(TestBasicState* state = nullptr, DataProcessor* dataProc = nullptr)
    {
        auto ptr = CommonTestClient::alloc();
        assert(ptr);
        ptr->setGwAdvertisePeriod(DefaultAdvertisePeriod);
        ptr->setRetryPeriod(DefaultRetryTimeout);
        ptr->setRetryCount(DefaultRetryCount);
        ptr->setBroadcastRadius(DefaultBroadcastRadius);
        ptr->setConnectionStatusReportCallback(
            [state](MqttsnConnectionStatus val)
            {
                TS_TRACE("Connect status reported: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedConnStatuses.push_back(val);
                }
            });
        ptr->setPublishCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Publish complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedPublishes.push_back(val);
                }
            });

        ptr->setSubsribeCompleteCallback(
            [state](MqttsnAsyncOpStatus val, MqttsnQoS qos)
            {
                TS_TRACE("Subscribe complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedSubsribes.push_back(std::make_pair(val, qos));
                }
            });

        ptr->setMessageReportCallback(
            [state](const MqttsnMessageInfo& msgInfo)
            {
                if (msgInfo.topic != nullptr) {
                    TS_TRACE(std::string("Received message with topic ") + msgInfo.topic);
                }
                else {
                    TS_TRACE(std::string("Received message with topic ID ") + std::to_string(msgInfo.topicId));
                }

                if (state != nullptr) {
                    state->m_reportedMsgs.push_back(msgInfo);
                }
            });
        ptr->setGwStatusReportCallback(
            [state](unsigned short gwId, MqttsnGwStatus status)
            {
                TS_TRACE(std::string("GW info reported: id=") + std::to_string(gwId) + "; status=" + std::to_string(status));
                if (state != nullptr) {
                    state->m_reportedGws.push_back(ReportedGwInfo(gwId, status));
                }
            });

        if (state != nullptr) {
            ptr->setProgramNextTickCallback(
                [state](unsigned duration)
                {
                    state->m_nextRequestedTicks = duration;
                });

            ptr->setCancelNextTickCallback(
                [state]() -> unsigned
                {
                    return state->m_nextElapsedTicks;
                });

            ptr->setSendDataCallback(
                [state](const std::uint8_t* buf, unsigned bufLen, bool broadcast)
                {
                    assert(state->m_nextOutput.empty());
//                    TS_TRACE("Sending " + std::to_string(bufLen) + " bytes; broadcast=" + std::to_string(broadcast));
                    state->m_nextOutput.insert(state->m_nextOutput.end(), buf, buf + bufLen);
                    state->m_broadcast = broadcast;
                });

        }

        if (dataProc != nullptr)
        {
            dataProc->setSearchgwMsgReportCallback(
                [](const SearchgwMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- SEARCHGW");
                });

            dataProc->setConnectMsgReportCallback(
                [](const ConnectMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- CONNECT");
                });

            dataProc->setWilltopicMsgReportCallback(
                [](const WilltopicMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLTOPIC");
                });

            dataProc->setWillmsgMsgReportCallback(
                [](const WillmsgMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLMSG");
                });

            dataProc->setRegisterMsgReportCallback(
                [](const RegisterMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGISTER");
                });

            dataProc->setRegackMsgReportCallback(
                [](const RegackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGACK");
                });

            dataProc->setPublishMsgReportCallback(
                [](const PublishMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBLISH");
                });

            dataProc->setPubackMsgReportCallback(
                [](const PubackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBACK");
                });

            dataProc->setPubrecMsgReportCallback(
                [](const PubrecMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREC");
                });

            dataProc->setPubrelMsgReportCallback(
                [](const PubrelMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREL");
                });

            dataProc->setPubcompMsgReportCallback(
                [](const PubcompMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBCOMP");
                });

            dataProc->setSubscribeMsgReportCallback(
                [](const SubscribeMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- SUBSCRIBE");
                });

            dataProc->setPingreqMsgReportCallback(
                [](const PingreqMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGREQ");
                });

            dataProc->setPingrespMsgReportCallback(
                [](const PingrespMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGRESP");
                });

        }

        return std::move(ptr);
    }

    void doGwInfo(CommonTestClient& client, DataProcessor& dataProc, TestBasicState& state)
    {
        verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);

        clearState(state);
        static const std::uint8_t GwId = 5U;
        auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
        TS_ASSERT(!gwInfoData.empty());

        state.m_nextElapsedTicks = 1 * 1000;
        dataFromGw(client, gwInfoData, "GWINFO");
        verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    }

    void doConnect(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        bool hasWill = false)
    {

        static const std::string ClientId = "test_client";
        static const std::string WillTopic("/this/is/will");
        static const std::vector<std::uint8_t> WillData{
            0x1, 0x2, 0x3, 0x4
        };
        static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
        static const bool WillRetain = false;

        static const auto WillInfoCreateFunc =
            []() -> MqttsnWillInfo
            {
                auto willInfo = MqttsnWillInfo();
                willInfo.topic = WillTopic.c_str();
                willInfo.msg = &WillData[0];
                willInfo.msgLen = WillData.size();
                willInfo.qos = WillQos;
                willInfo.retain = WillRetain;
                return willInfo;
            };

        static const MqttsnWillInfo WillInfo = WillInfoCreateFunc();
        TS_TRACE("Connecting...");
        state.m_nextElapsedTicks = 0;

        const MqttsnWillInfo* willInfo = nullptr;
        if (hasWill) {
            willInfo = &WillInfo;
        }
        auto result =
            client.connect(ClientId.c_str(), DefaultKeepAlive, true, willInfo);
        TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
        verifySent_ConnectMsg(state, dataProc, ClientId, DefaultKeepAlive, true, willInfo != nullptr);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

        clearState(state);

        if (hasWill) {
            auto willTopicReq = dataProc.prepareWilltopicreqMsg();
            dataFromGw(client, willTopicReq, "WILLTOPICREQ");
            verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

            clearState(state);
            auto willMsgReq = dataProc.prepareWillmsgreqMsg();
            dataFromGw(client, willMsgReq, "WILLMSGREQ");
            verifySent_WillmsgMsg(state, dataProc, WillData);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

            clearState(state);
        }

        auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
        dataFromGw(client, connackMsg, "CONNACK");
        verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Connected);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
    }

    void startClient(CommonTestClient& client)
    {
        bool result = client.start();
        TS_ASSERT(result);
    }

    void doTopicRegister(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        const std::string& topic,
        MqttsnTopicId topicId,
        std::uint16_t msgId)
    {
        clearState(state);
        auto registerMsg = dataProc.prepareRegisterMsg(topicId, msgId, topic);
        state.m_nextElapsedTicks = 1000;
        dataFromGw(client, registerMsg, "REGISTER");
        verifySent_RegackMsg(state, dataProc, topicId, msgId);
    }

    void processOutput(
        const TestBasicState& state,
        DataProcessor& dataProc,
        bool broadcast = false)
    {
        TS_ASSERT(!state.m_nextOutput.empty());
        TS_ASSERT_EQUALS(state.m_broadcast, broadcast);
        dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());
    }

    void verifySent_SearchgwMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        unsigned short radius)
    {
        bool sent = false;
        auto oldCb = dataProc.setSearchgwMsgReportCallback(
            [&sent, radius](const SearchgwMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- SEARCHGW");
                auto& fields = msg.fields();
                auto& radiusField = std::get<SearchgwMsg::FieldIdx_radus>(fields);
                TS_ASSERT_EQUALS(radiusField.value(), radius);
            });

        processOutput(state, dataProc, true);
        TS_ASSERT(sent);

        dataProc.setSearchgwMsgReportCallback(std::move(oldCb));
    }

    void verifySent_ConnectMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& clientId,
        unsigned short keepAlivePeriod,
        bool cleanSession,
        bool hasWill)
    {
        bool sent = false;
        auto oldCb = dataProc.setConnectMsgReportCallback(
            [&sent, &clientId, keepAlivePeriod, cleanSession, hasWill](const ConnectMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- CONNECT");
                auto& fields = msg.fields();
                auto& flagsField = std::get<ConnectMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& midFlags = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                auto& protocolIdField = std::get<ConnectMsg::FieldIdx_protocolId>(fields);
                auto& durationField = std::get<ConnectMsg::FieldIdx_duration>(fields);
                auto& clientIdField = std::get<ConnectMsg::FieldIdx_clientId>(fields);

                TS_ASSERT_EQUALS(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_cleanSession), cleanSession);
                TS_ASSERT_EQUALS(midFlags.getBitValue(mqttsn::protocol::field::MidFlagsBits_will), hasWill);
                TS_ASSERT_EQUALS(protocolIdField.value(), 1);
                TS_ASSERT_EQUALS(durationField.value(), keepAlivePeriod);
                TS_ASSERT_EQUALS(clientIdField.value(), clientId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);

        dataProc.setConnectMsgReportCallback(std::move(oldCb));
    }

    void verifySent_WilltopicMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic,
        MqttsnQoS qos,
        bool retain)
    {
        bool sent = false;
        auto oldCb = dataProc.setWilltopicMsgReportCallback(
            [&sent, &topic, qos, retain](const WilltopicMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- WILLTOPIC");
                auto& fields = msg.fields();
                auto& flagsField = std::get<WilltopicMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                auto& topicField = std::get<WilltopicMsg::FieldIdx_willTopic>(fields);

                TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), retain);
                TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), qos);
                TS_ASSERT_EQUALS(topicField.value(), topic);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWilltopicMsgReportCallback(std::move(oldCb));
    }

    void verifySent_WillmsgMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::vector<std::uint8_t>& data)
    {
        bool sent = false;
        auto oldCb = dataProc.setWillmsgMsgReportCallback(
            [&sent, &data](const WillmsgMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- WILLMSG");
                auto& fields = msg.fields();
                auto& willMsgField = std::get<WillmsgMsg::FieldIdx_willMsg>(fields);

                TS_ASSERT_EQUALS(willMsgField.value(), data);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWillmsgMsgReportCallback(std::move(oldCb));
    }

    std::uint16_t verifySent_RegisterMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic)
    {
        std::uint16_t msgId = 0;
        bool sent = false;
        auto oldCb = dataProc.setRegisterMsgReportCallback(
            [&msgId, &sent, &topic](const RegisterMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- REGISTER");
                auto& fields = msg.fields();
                auto& topicIdField = std::get<RegisterMsg::FieldIdx_topicId>(fields);
                auto& msgIdField = std::get<RegisterMsg::FieldIdx_msgId>(fields);
                auto& topicNameField = std::get<RegisterMsg::FieldIdx_topicName>(fields);

                TS_ASSERT_EQUALS(topicIdField.value(), 0U);
                TS_ASSERT_EQUALS(topicNameField.value(), topic);
                msgId = msgIdField.value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setRegisterMsgReportCallback(std::move(oldCb));
        return msgId;

    }

    void verifySent_RegackMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        std::uint16_t msgId,
        mqttsn::protocol::field::ReturnCodeVal retCode = mqttsn::protocol::field::ReturnCodeVal_Accepted)
    {
        bool sent = false;
        auto oldCb = dataProc.setRegackMsgReportCallback(
            [&sent, topicId, msgId, retCode](const RegackMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- REGACK");

                auto& fields = msg.fields();
                auto& topicIdField = std::get<RegackMsg::FieldIdx_topicId>(fields);
                auto& msgIdField = std::get<RegackMsg::FieldIdx_msgId>(fields);
                auto& retCodeField = std::get<RegackMsg::FieldIdx_returnCode>(fields);

                TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                TS_ASSERT_EQUALS(retCodeField.value(), retCode);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setRegackMsgReportCallback(std::move(oldCb));
    }

    std::uint16_t verifySent_PublishMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        const DataSeq& data,
        TopicIdTypeVal topicIdType,
        MqttsnQoS qos,
        bool retain,
        bool duplicate)
    {
        std::uint16_t msgId = 0;
        bool sent = false;
        auto oldCb = dataProc.setPublishMsgReportCallback(
            [&msgId, &sent, &data, topicId, topicIdType, qos, retain, duplicate](const PublishMsg& msg)
            {
                sent = true;

                TS_TRACE("<-- PUBLISH");
                auto& fields = msg.fields();
                auto& flagsField = std::get<PublishMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& topicIdTypeField = std::get<mqttsn::protocol::field::FlagsMemberIdx_topicId>(flagsMembers);
                auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
                auto& topicIdField = std::get<PublishMsg::FieldIdx_topicId>(fields);
                auto& msgIdField = std::get<PublishMsg::FieldIdx_msgId>(fields);
                auto& dataField = std::get<PublishMsg::FieldIdx_data>(fields);

                TS_ASSERT_EQUALS(topicIdTypeField.value(), topicIdType);
                TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), retain);
                TS_ASSERT_EQUALS(CommonTestClient::transformQos(qosField.value()), qos);
                TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), duplicate);
                TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                TS_ASSERT_EQUALS(dataField.value(), data);

                msgId = msgIdField.value();
                TS_TRACE("msg_id=" + std::to_string(msgId));
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPublishMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    void verifySent_PubackMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        std::uint16_t msgId,
        mqttsn::protocol::field::ReturnCodeVal retCode = mqttsn::protocol::field::ReturnCodeVal_Accepted)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubackMsgReportCallback(
            [&sent, topicId, msgId, retCode](const PubackMsg& msg)
            {
                TS_TRACE("<-- PUBACK");
                sent = true;

                auto& fields = msg.fields();
                auto& topicIdField = std::get<PubackMsg::FieldIdx_topicId>(fields);
                auto& msgIdField = std::get<PubackMsg::FieldIdx_msgId>(fields);
                auto& retCodeField = std::get<PubackMsg::FieldIdx_returnCode>(fields);

                TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                TS_ASSERT_EQUALS(retCodeField.value(), retCode);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubackMsgReportCallback(std::move(oldCb));
    }

    void verifySent_PubrecMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubrecMsgReportCallback(
            [&sent, msgId](const PubrecMsg& msg)
            {
                TS_TRACE("<-- PUBREC");
                sent = true;

                auto& fields = msg.fields();
                auto& msgIdField = std::get<PubrecMsg::FieldIdx_msgId>(fields);

                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubrecMsgReportCallback(std::move(oldCb));
    }

    void verifySent_PubrelMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubrelMsgReportCallback(
            [&](const PubrelMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- PUBREL");

                auto& fields = msg.fields();
                auto& msgIdField = std::get<PubrelMsg::FieldIdx_msgId>(fields);

                TS_ASSERT_EQUALS(msgIdField.value(), msgId);

            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubrelMsgReportCallback(std::move(oldCb));
    }

    void verifySent_PubcompMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubcompMsgReportCallback(
            [&sent, msgId](const PubcompMsg& msg)
            {
                TS_TRACE("<-- PUBCOMP");
                sent = true;

                auto& fields = msg.fields();
                auto& msgIdField = std::get<PubcompMsg::FieldIdx_msgId>(fields);

                TS_ASSERT_EQUALS(msgIdField.value(), msgId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubcompMsgReportCallback(std::move(oldCb));
    }

    std::uint16_t verifySent_SubsribeMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic,
        MqttsnQoS qos,
        bool duplicate)
    {
        bool sent = false;
        std::uint16_t msgId = 0U;
        auto oldCb = dataProc.setSubscribeMsgReportCallback(
            [&sent, &msgId, &topic, qos, duplicate](const SubscribeMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- SUBSRIBE");

                auto& fields = msg.fields();
                auto& flagsField = std::get<SubscribeMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& topicIdTypeField = std::get<mqttsn::protocol::field::FlagsMemberIdx_topicId>(flagsMembers);
                auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
                auto& msgIdField = std::get<SubscribeMsg::FieldIdx_msgId>(fields);
                auto& topicIdField = std::get<SubscribeMsg::FieldIdx_topicId>(fields);
                auto& topicNameField = std::get<SubscribeMsg::FieldIdx_topicName>(fields);

                TS_ASSERT_EQUALS(topicIdTypeField.value(), mqttsn::protocol::field::TopicIdTypeVal::Name);
                TS_ASSERT_EQUALS(transformQos(qosField.value()), qos);
                TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), duplicate);
                TS_ASSERT_EQUALS(topicIdField.getMode(), comms::field::OptionalMode::Missing);
                TS_ASSERT_EQUALS(topicNameField.getMode(), comms::field::OptionalMode::Exists);
                TS_ASSERT_EQUALS(topicNameField.field().value(), topic);

                msgId = msgIdField.value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setSubscribeMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    std::uint16_t verifySent_SubsribeMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        MqttsnQoS qos,
        bool duplicate)
    {
        bool sent = false;
        std::uint16_t msgId = 0U;
        auto oldCb = dataProc.setSubscribeMsgReportCallback(
            [&sent, &msgId, topicId, qos, duplicate](const SubscribeMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- SUBSCRIBE");

                auto& fields = msg.fields();
                auto& flagsField = std::get<SubscribeMsg::FieldIdx_flags>(fields);
                auto& flagsMembers = flagsField.value();
                auto& topicIdTypeField = std::get<mqttsn::protocol::field::FlagsMemberIdx_topicId>(flagsMembers);
                auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
                auto& msgIdField = std::get<SubscribeMsg::FieldIdx_msgId>(fields);
                auto& topicIdField = std::get<SubscribeMsg::FieldIdx_topicId>(fields);
                auto& topicNameField = std::get<SubscribeMsg::FieldIdx_topicName>(fields);

                TS_ASSERT_EQUALS(topicIdTypeField.value(), mqttsn::protocol::field::TopicIdTypeVal::PreDefined);
                TS_ASSERT_EQUALS(transformQos(qosField.value()), qos);
                TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), duplicate);
                TS_ASSERT_EQUALS(topicIdField.getMode(), comms::field::OptionalMode::Exists);
                TS_ASSERT_EQUALS(topicNameField.getMode(), comms::field::OptionalMode::Missing);
                TS_ASSERT_EQUALS(topicIdField.field().value(), topicId);

                msgId = msgIdField.value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setSubscribeMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    void verifySent_PingreqMsg(
        const TestBasicState& state,
        DataProcessor& dataProc)
    {
        bool sent = false;
        auto oldCb = dataProc.setPingreqMsgReportCallback(
            [&sent](const PingreqMsg& msg)
            {
                sent = true;
                static_cast<void>(msg);
                TS_TRACE("<-- PINGREQ");
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPingreqMsgReportCallback(std::move(oldCb));
    }

    void verifySent_PingrespMsg(
        const TestBasicState& state,
        DataProcessor& dataProc)
    {
        bool sent = false;
        auto oldCb = dataProc.setPingrespMsgReportCallback(
            [&sent](const PingrespMsg& msg)
            {
                sent = true;
                static_cast<void>(msg);
                TS_TRACE("<-- PINGRESP");
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPingrespMsgReportCallback(std::move(oldCb));
    }

    void verifySent_DisconnectMsg(
        const TestBasicState& state,
        DataProcessor& dataProc)
    {
        bool sent = false;
        auto oldCb = dataProc.setDisconnectMsgReportCallback(
            [&sent](const DisconnectMsg& msg)
            {
                sent = true;
                static_cast<void>(msg);
                TS_TRACE("<-- DISCONNECT");
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setDisconnectMsgReportCallback(std::move(oldCb));
    }

    void verifyCb_ReportedGw(
        TestBasicState& state,
        std::uint16_t gwId,
        MqttsnGwStatus status)
    {
        TS_ASSERT(!state.m_reportedGws.empty());
        if (state.m_reportedGws.empty()) {
            return;
        }

        auto& gw = state.m_reportedGws.front();
        TS_ASSERT_EQUALS(gw.m_id, gwId);
        TS_ASSERT_EQUALS(gw.m_status, status);
        state.m_reportedGws.pop_front();
    }

    void verifyCb_ReportedMessage(
        TestBasicState& state,
        const std::string& topic,
        MqttsnTopicId topicId,
        const std::vector<std::uint8_t>& data,
        MqttsnQoS qos,
        bool retain)
    {
        TS_ASSERT(!state.m_reportedMsgs.empty());
        if (state.m_reportedMsgs.empty()) {
            return;
        }

        auto& msg = state.m_reportedMsgs.front();
        TS_ASSERT_EQUALS(msg.m_topic, topic);
        TS_ASSERT_EQUALS(msg.m_topicId, topicId);
        TS_ASSERT_EQUALS(msg.m_data, data);
        TS_ASSERT_EQUALS(msg.m_qos, qos);
        TS_ASSERT_EQUALS(msg.m_retain, retain);
        state.m_reportedMsgs.pop_front();
    }

    void verifyCb_ReportedConnStatus(
        TestBasicState& state,
        MqttsnConnectionStatus status)
    {
        TS_ASSERT(!state.m_reportedConnStatuses.empty());
        if (state.m_reportedConnStatuses.empty()) {
            return;
        }

        TS_ASSERT_EQUALS(state.m_reportedConnStatuses.front(), status);
        state.m_reportedConnStatuses.pop_front();
    }

    void verifyCb_ReportedPublish(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedPublishes.empty());
        if (state.m_reportedPublishes.empty()) {
            return;
        }

        TS_ASSERT_EQUALS(state.m_reportedPublishes.front(), status);
        state.m_reportedPublishes.pop_front();
    }

    void verifyCb_ReportedSubsribe(
        TestBasicState& state,
        MqttsnAsyncOpStatus status,
        MqttsnQoS qos)
    {
        TS_ASSERT(!state.m_reportedSubsribes.empty());
        if (state.m_reportedSubsribes.empty()) {
            return;
        }

        auto& elem = state.m_reportedSubsribes.front();

        TS_ASSERT_EQUALS(elem.first, status);
        TS_ASSERT_EQUALS(elem.second, qos);
        state.m_reportedSubsribes.pop_front();
    }

    static MqttsnQoS transformQos(mqttsn::protocol::field::QosType val)
    {
        return CommonTestClient::transformQos(val);
    }

    static mqttsn::protocol::field::QosType transformQos(MqttsnQoS val)
    {
        return CommonTestClient::transformQos(val);
    }
};

void ClientBasic::test1()
{
    auto client = allocClient();
    static_cast<void>(client);
}

void ClientBasic::test2()
{
    DataProcessor dataProc;
    typedef TestBasicState Test2State;
    Test2State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    TS_TRACE("Started");
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    TS_TRACE("Tick");
    client->tick(DefaultRetryTimeout);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    static const std::uint8_t GwId = 5U;
    auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
    TS_ASSERT(!gwInfoData.empty());

    assert(state.m_nextRequestedTicks == 0U);
    state.m_nextElapsedTicks = 1 * 1000;
    dataFromGw(*client, gwInfoData, "GWINFO");

    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultAdvertisePeriod);

    clearState(state);
    client->tick(DefaultAdvertisePeriod);
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_TimedOut);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    auto advertiseData = dataProc.prepareAdvertiseMsg(GwId, (DefaultAdvertisePeriod / 1000) + 1);
    TS_ASSERT(!advertiseData.empty());
    state.m_nextElapsedTicks = 1 * 1000;

    dataFromGw(*client, advertiseData, "ADVERTISE");
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultAdvertisePeriod  + 1000);

    clearState(state);
    client->tick(DefaultAdvertisePeriod  + 1000);
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_TimedOut);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
}

void ClientBasic::test3()
{
    // Connect without will
    DataProcessor dataProc;
    struct Test3State : public TestBasicState
    {
        MqttsnConnectionStatus m_connectionStatus = MqttsnConnectionStatus_Invalid;
    };

    Test3State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    client->setConnectionStatusReportCallback(
        [&](MqttsnConnectionStatus val)
        {
            // First connect is expected to be timed out
            TS_TRACE("Connect status reported: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnConnectionStatus_Timeout);

            client->setConnectionStatusReportCallback(
                [&](MqttsnConnectionStatus val2)
                {
                    TS_TRACE("Connect status reported: " + std::to_string((int)val2));
                    TS_ASSERT_EQUALS(val2, MqttsnConnectionStatus_Connected);
                    state.m_connectionStatus = val2;
                });

            TS_TRACE("Reconnecting...");
            auto result2 =
                client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

            TS_ASSERT_EQUALS(result2, MqttsnErrorCode_Success);

        });

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);

    // Timeout and new connect attempt is expected here

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    clearState(state);
    auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");

    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnConnectionStatus_Connected);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, KeepAlive * 1000);
}

void ClientBasic::test4()
{
    // Connect with will
    DataProcessor dataProc;
    typedef TestBasicState Test4State;

    Test4State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;
    static const std::string WillTopic("/this/is/will");
    static const std::vector<std::uint8_t> WillData{
        0x1, 0x2, 0x3, 0x4
    };
    static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool WillRetain = false;

    TS_TRACE("Connecting...");
    auto willInfo = MqttsnWillInfo();
    willInfo.topic = WillTopic.c_str();
    willInfo.msg = &WillData[0];
    willInfo.msgLen = WillData.size();
    willInfo.qos = WillQos;
    willInfo.retain = WillRetain;

    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, &willInfo);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);

    // Send ack message, check ignored
    state.m_nextElapsedTicks = 1000;
    auto connackMsg = dataProc.prepareConnackMsg(mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");
    // Ack must be ignored
    TS_ASSERT(state.m_reportedConnStatuses.empty());
    TS_ASSERT(state.m_nextOutput.empty())

    auto willTopicReq = dataProc.prepareWilltopicreqMsg();
    dataFromGw(*client, willTopicReq, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);

    client->tick(nextTick); // Timeout is expected, new connect attempt

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, willTopicReq, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto willMsgReq = dataProc.prepareWillmsgreqMsg();
    dataFromGw(*client, willMsgReq, "WILLMSGREQ");
    verifySent_WillmsgMsg(state, dataProc, WillData);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, connackMsg, "CONNACK");

    // check connected
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Connected);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, KeepAlive * 1000);
}

void ClientBasic::test5()
{
    DataProcessor dataProc;
    typedef TestBasicState Test5State;
    Test5State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    auto nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, DefaultKeepAlive * 1000);

    client->tick(nextTicks);
    verifySent_PingreqMsg(state, dataProc);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingRespMsg = dataProc.preparePingrespMsg();
    dataFromGw(*client, pingRespMsg, "PINGRESP");

    TS_ASSERT(state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);

    nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, DefaultKeepAlive * 1000);

    clearState(state);
    client->tick(nextTicks);
    verifySent_PingreqMsg(state, dataProc);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifySent_PingreqMsg(state, dataProc);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifySent_PingreqMsg(state, dataProc);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test6()
{
    DataProcessor dataProc;
    typedef TestBasicState Test6State;
    Test6State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingreqMsg = dataProc.preparePingreqMsg();
    dataFromGw(*client, pingreqMsg, "PINGREQ");
    verifySent_PingrespMsg(state, dataProc);

    clearState(state);
    TS_ASSERT(state.m_reportedConnStatuses.empty());
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test7()
{
    DataProcessor dataProc;
    typedef TestBasicState Test7State;
    Test7State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc);

    TS_ASSERT(state.m_reportedConnStatuses.empty());
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    state.m_nextElapsedTicks = 1000;
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test8()
{
    DataProcessor dataProc;
    typedef TestBasicState Test8State;
    Test8State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);

    TS_ASSERT(state.m_nextOutput.empty());
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test9()
{
    DataProcessor dataProc;
    typedef TestBasicState Test9State;
    Test9State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    auto nextTick = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTick);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_ConnectAborted);
}

void ClientBasic::test10()
{
    DataProcessor dataProc;
    typedef TestBasicState Test10State;
    Test10State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    state.m_nextElapsedTicks = 1000;
    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    verifyCb_ReportedConnStatus(state, MqttsnConnectionStatus_Disconnected);
}

void ClientBasic::test11()
{
    DataProcessor dataProc;
    typedef TestBasicState Test11State;
    Test11State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
}

void ClientBasic::test12()
{
    DataProcessor dataProc;
    typedef TestBasicState Test12State;
    Test12State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);

    static const MqttsnTopicId TopicId = 0x0123;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const MqttsnQoS Qos = MqttsnQoS_NoGwPublish;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), MqttsnQoS_AtMostOnceDelivery, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);
    TS_ASSERT(state.m_reportedPublishes.empty());
    TS_ASSERT(state.m_nextOutput.empty());

    result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
}

void ClientBasic::test13()
{
    DataProcessor dataProc;
    typedef TestBasicState Test13State;
    Test13State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdTypeVal::PreDefined, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    auto msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    TS_ASSERT(state.m_nextOutput.empty()); // must be ignored

    clearState(state);
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
}

void ClientBasic::test14()
{
    DataProcessor dataProc;
    typedef TestBasicState Test14State;
    Test14State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_InvalidId);
}

void ClientBasic::test15()
{
    DataProcessor dataProc;
    typedef TestBasicState Test15State;
    Test15State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    clearState(state);

    state.m_nextElapsedTicks = 2000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    auto msgId2 = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT_EQUALS(msgId, msgId2);
    TS_ASSERT(state.m_reportedPublishes.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    clearState(state);
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test16()
{
    DataProcessor dataProc;
    typedef TestBasicState Test16State;
    Test16State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    static const MqttsnTopicId TopicId = 0x1234;
    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    TS_ASSERT(state.m_nextOutput.empty());

    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);

    clearState(state);
    state.m_nextElapsedTicks = 1000;

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000 - state.m_nextElapsedTicks);
}

void ClientBasic::test17()
{
    DataProcessor dataProc;
    typedef TestBasicState Test17State;
    Test17State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_NoResponse);
    TS_ASSERT(state.m_nextOutput.empty());
}

void ClientBasic::test18()
{
    DataProcessor dataProc;
    typedef TestBasicState Test18State;
    Test18State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(state.m_reportedPublishes.empty());
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test19()
{
    DataProcessor dataProc;
    typedef TestBasicState Test19State;
    Test19State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_reportedPublishes.empty());
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test20()
{
    DataProcessor dataProc;
    typedef TestBasicState Test20State;
    Test20State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_reportedPublishes.empty());
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_InvalidId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test21()
{
    DataProcessor dataProc;
    typedef TestBasicState Test21State;
    Test21State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Aborted);

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Aborted);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
}

void ClientBasic::test22()
{
    DataProcessor dataProc;
    typedef TestBasicState Test22State;
    Test22State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t RegMsgId = 0x1234;
    static const MqttsnTopicId TopicId = 0x2222;
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    auto registerMsg = dataProc.prepareRegisterMsg(TopicId, RegMsgId, Topic);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, registerMsg, "REGISTER");
    verifySent_RegackMsg(state, dataProc, TopicId, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
}

void ClientBasic::test23()
{
    DataProcessor dataProc;
    typedef TestBasicState Test23State;
    Test23State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic1("this/is/topic1");
    static const std::string Topic2("this/is/topic2");
    static const MqttsnTopicId Topic1Id = 0x1234;
    static const MqttsnTopicId Topic2Id = 0x4321;
    static const std::uint16_t RegMsgId = 0x2222;
    static const MqttsnQoS Qos1 = MqttsnQoS_ExactlyOnceDelivery;
    static const MqttsnQoS Qos2 = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic1, &Data[0], Data.size(), Qos1, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic1);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(Topic1Id, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    msgId = verifySent_PublishMsg(state, dataProc, Topic1Id, Data, TopicIdTypeVal::Normal, Qos1, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    doTopicRegister(*client, dataProc, state, Topic2, Topic2Id, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->publish(Topic2, &Data[0], Data.size(), Qos2, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    msgId = verifySent_PublishMsg(state, dataProc, Topic2Id, Data, TopicIdTypeVal::Normal, Qos2, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(Topic2Id, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
}

void ClientBasic::test24()
{
    DataProcessor dataProc;
    typedef TestBasicState Test24State;
    Test24State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x1234;
    static const std::uint16_t MsgId = 0x5555;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const auto Qos = mqttsn::protocol::field::QosType::AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, MsgId, Data, TopicIdType, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifyCb_ReportedMessage(state, std::string(), TopicId, Data, transformQos(Qos), Retain);
    TS_ASSERT(state.m_nextOutput.empty());

    static const char* Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, MsgId + 1, Data, TopicIdType, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
    TS_ASSERT(state.m_nextOutput.empty());
}

void ClientBasic::test25()
{
    DataProcessor dataProc;
    typedef TestBasicState Test25State;

    Test25State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const auto Qos = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty()); // Duplicated mustn't be reported

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    expectedMsgId = MsgId + 1;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
}

void ClientBasic::test26()
{
    DataProcessor dataProc;
    typedef TestBasicState Test26State;

    Test26State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto TopicIdType = TopicIdTypeVal::PreDefined;
    static const auto Qos = mqttsn::protocol::field::QosType::ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty()); // Duplicate not reported

    clearState(state);
    ++expectedMsgId;
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
}

void ClientBasic::test27()
{
    DataProcessor dataProc;
    typedef TestBasicState Test27State;

    Test27State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x1234;
    static const auto Qos = MqttsnQoS_AtLeastOnceDelivery;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->subscribe(TopicId, Qos);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_SubsribeMsg(state, dataProc, TopicId, Qos, false);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto subackMsg = dataProc.prepareSubackMsg(transformQos(Qos), TopicId, msgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    TS_ASSERT(state.m_reportedSubsribes.empty());

    auto nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick(nextTicks);
    auto msgId2 = verifySent_SubsribeMsg(state, dataProc, TopicId, Qos, true);
    TS_ASSERT_EQUALS(msgId, msgId2);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    subackMsg = dataProc.prepareSubackMsg(transformQos(Qos), TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Successful, Qos);
}

