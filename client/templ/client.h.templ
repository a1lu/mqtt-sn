//
// Copyright 2016 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#pragma once

#include "mqttsn/client/common.h"

#ifdef __cplusplus
extern "C" {
#endif // #ifdef __cplusplus

/// @brief Allocate new client.
/// @details When work with the client is complete, mqttsn_client_free()
///     function, must be invoked.
/// @return Handle to allocated client object. This handle needs to be passed
///     as first parameter to all other API functions.
MqttsnClientHandle mqttsn_##NAME##client_new();

/// @brief Free previously allocated client.
/// @details When used communication channel to the gateway is no longer
///     needed, the client data structes allocated with 
///     mqttsn_##NAME##client_new() must be released using this function.
/// @param[in] client Handle returned by mqttsn_##NAME##client_new() function.
void mqttsn_##NAME##client_free(MqttsnClientHandle client);

/// @brief Set callback to call when time measurement is required.
/// @details The MQTT-SN client may require to measure time. When such 
///     measurement is required, the provided callback will be invoked with
///     the timeout duration in milliseconds. After requested time expires,
//      the mqttsn_##NAME##client_tick() function must be invoked.
/// @param[in] client Handle returned by mqttsn_##NAME##client_new() function.
/// @param[in] fn Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void mqttsn_##NAME##client_set_next_tick_program_callback(
    MqttsnClientHandle client,
    MqttsnNextTickProgramFn fn,
    void* data);
    
/// @brief Set callback to terminate current time measurement.
/// @details The client may request termination of currently running time 
///     measurement, previously requested via callback, which was set using
///     mqttsn_##NAME##client_set_next_tick_program_callback() function. This function
///     sets appropriate callback. When invoked, it must returned number of
///     elapsed milliseconds since previoius time measurement request.
/// @param[in] client Handle returned by mqttsn_##NAME##client_new() function.
/// @param[in] fn Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void mqttsn_##NAME##client_set_cancel_next_tick_wait_callback(
    MqttsnClientHandle client,
    MqttsnCancelNextTickWaitFn fn,
    void* data);
    
/// @brief Set callback to send raw data over I/O link.
/// @details The callback is invoked when there is a need to send data
///     to the gateway.
/// @param[in] client Handle returned by mqttsn_##NAME##client_new() function.
/// @param[in] fn Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void mqttsn_##NAME##client_set_send_output_data_callback(
    MqttsnClientHandle client,
    MqttsnSendOutputDataFn fn,
    void* data);
    
/// @brief Set callback to report status of the gateway.
/// @details The callback is invoked when gateway status has changed.
/// @param[in] client Handle returned by mqttsn_##NAME##client_new() function.
/// @param[in] fn Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void mqttsn_##NAME##client_set_gw_status_report_callback(
    MqttsnClientHandle client,
    MqttsnGwStatusReportFn fn,
    void* data);
    
void mqttsn_##NAME##client_set_connection_status_report_callback(
    MqttsnClientHandle client,
    MqttsnConnectionStatusReportFn fn,
    void* data);

void mqttsn_##NAME##client_set_message_report_callback(
    MqttsnClientHandle client,
    MqttsnMessageReportFn fn,
    void* data);
    
MqttsnErrorCode mqttsn_##NAME##client_start(MqttsnClientHandle client);
MqttsnErrorCode mqttsn_##NAME##client_stop(MqttsnClientHandle client);
unsigned mqttsn_##NAME##client_process_data(MqttsnClientHandle client, const unsigned char* from, unsigned len);
void mqttsn_##NAME##client_tick(MqttsnClientHandle client, unsigned ms);
void mqttsn_##NAME##client_set_retry_period(MqttsnClientHandle client, unsigned value);
void mqttsn_##NAME##client_set_retry_count(MqttsnClientHandle client, unsigned value);
void mqttsn_##NAME##client_set_broadcast_radius(MqttsnClientHandle client, unsigned char value);
void mqttsn_##NAME##client_set_searchgw_enabled(MqttsnClientHandle client, bool value);
void mqttsn_##NAME##client_search_gw(MqttsnClientHandle client);
void mqttsn_##NAME##client_discard_gw(MqttsnClientHandle client, unsigned char gwId);
void mqttsn_##NAME##client_discard_all_gw(MqttsnClientHandle client);

bool mqttsn_##NAME##client_cancel(MqttsnClientHandle client);

MqttsnErrorCode mqttsn_##NAME##client_connect(
    MqttsnClientHandle client,
    const char* clientId,
    unsigned short keepAliveSeconds,
    bool cleanSession,
    const MqttsnWillInfo* willInfo);

MqttsnErrorCode mqttsn_##NAME##client_disconnect(MqttsnClientHandle client);

MqttsnErrorCode mqttsn_##NAME##client_publish_id(
    MqttsnClientHandle client,
    MqttsnTopicId topicId,
    const unsigned char* msg,
    unsigned msgLen,
    MqttsnQoS qos,
    bool retain,
    MqttsnPublishCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_publish(
    MqttsnClientHandle client,
    const char* topic,
    const unsigned char* msg,
    unsigned msgLen,
    MqttsnQoS qos,
    bool retain,
    MqttsnPublishCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_subscribe_id(
    MqttsnClientHandle client,
    MqttsnTopicId topicId,
    MqttsnQoS qos,
    MqttsnSubscribeCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_subscribe(
    MqttsnClientHandle client,
    const char* topic,
    MqttsnQoS qos,
    MqttsnSubscribeCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_unsubscribe_id(
    MqttsnClientHandle client,
    MqttsnTopicId topicId,
    MqttsnUnsubscribeCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_unsubscribe(
    MqttsnClientHandle client,
    const char* topic,
    MqttsnUnsubscribeCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_will_update(
    MqttsnClientHandle client,
    const MqttsnWillInfo* willInfo,
    MqttsnWillUpdateCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_will_topic_update(
    MqttsnClientHandle client,
    const char* topic,
    MqttsnQoS qos,
    bool retain,
    MqttsnWillTopicUpdateCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_will_msg_update(
    MqttsnClientHandle client,
    const unsigned char* msg,
    unsigned msgLen,
    MqttsnWillMsgUpdateCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_sleep(
    MqttsnClientHandle client,
    unsigned short duration,
    MqttsnSleepCompleteReportFn callback,
    void* data
);

MqttsnErrorCode mqttsn_##NAME##client_check_messages(
    MqttsnClientHandle client,
    MqttsnCheckMessagesCompleteReportFn callback,
    void* data
);

#ifdef __cplusplus
}
#endif
