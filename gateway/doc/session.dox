/// @page mqttsn_gw_session_page Session
/// @tableofcontents
/// The @b Session object is responsible to manage and forward traffic of
/// messages between @b single MQTT-SN client and the broker. When new message
/// is received over the I/O link, the driving code must check whether any
/// @b Session object has already been created for the client that sent the
/// message (the clients can be differentiated by their origin address). If
/// such @b Session does NOT exist, it must be created. 
///
/// The received data needs to be forwarded to appropriate @b Session object 
/// for processing. And when the @b Session object requests to send message
/// back, it needs to be sent to the right address. It is a responsibility of
/// the driving code to maintain a valid map between the client's address and
/// appropriate @b Session object.
///
/// @section mqttsn_gw_session_page_alloc Allocation
/// When using @b C++ interface, just instantiate object of mqttsn::gateway::Session
/// class. The destruction of the object will clean up all acquired resources.
/// @code
/// mqttsn::gateway::Session* session = new mqttsn::gateway::Session(); // make sure to use smart pointer in production code
/// @endcode
///
/// When using @b C interface, the allocation is performed using mqttsn_gw_session_alloc()
/// @code
/// MqttsnSessionHandle handle = mqttsn_gw_session_alloc();
/// @endcode
/// and de-allocation is performed using mqttsn_gw_session_free() functions.
/// @code
/// mqttsn_gw_session_free(handle);
/// @endcode
///
/// @section mqttsn_gw_session_page_recv Receiving Data
/// The MQTT-SN gateway @b Session serves as message translator and forwarder between
/// MQTT-SN client and MQTT broker. The driver code is responsible to
/// manage these two independent communication links. Once a message is
/// received on any of them, it must be provided the the @b Session object
/// for processing.
///
/// @subsection mqttsn_gw_session_page_recv_client Receiving Data from Client
/// @b C++ interface:
/// @code
/// std::size_t consumed = session->dataFromClient(buf, bufLen);
/// @endcode
/// 
/// @b C interface:
/// @code
/// unsigned consumed = mqttsn_gw_session_data_from_client(handle, buf, bufLen);
/// @endcode
///
/// @b NOTE, that functions return number of bytes that were actually processed. 
/// If number of processed bytes is less that number of bytes residing in the 
/// buffer, then probably some unexpected protocol error has occurred.
///
/// The call to this function may cause invocation of various callback functions
/// that have been set.
///
/// @subsection mqttsn_gw_session_page_recv_broker Receiving Data from Broker
/// @b C++ interface:
/// @code
/// std::size_t consumed = session->dataFromBroker(buf, bufLen);
/// @endcode
/// 
/// @b C interface:
/// @code
/// unsigned consumed = mqttsn_gw_session_data_from_broker(handle, buf, bufLen);
/// @endcode
///
/// @b NOTE, that functions return number of bytes that were actually processed. 
/// If number of processed bytes is less that number of bytes residing in the 
/// buffer, then probably some unexpected protocol error has occurred.
///
/// The call to this function may cause invocation of various callback functions
/// that have been set.
///
/// @section mqttsn_gw_session_page_send Sending Data
/// The @b Session object may require to send a message to either client or
/// broker. The driving code has to provide appropriate callbacks for this 
/// purpose. When the callback is invoked, it is provided with pointer to
/// data buffer. This buffer resides in internal data structures of the
/// @b Session object. After the callback returns, this buffer may be updated.
/// It means, that the driving code may require to copy the buffer to its
/// internal data structures to preserve the data intact until send over I/O
/// link operation is complete.
///
/// @subsection mqttsn_gw_session_page_send_client Sending Data to Client
/// @b C++ interface:
/// @code
/// session->setSendDataClientReqCb(
///     [](const std::uint8_t* buf, std::size_t bufLen)
///     {
///         ... 
///     });
/// @endcode
///
/// @b C interface:
/// @code
/// void my_send_to_client(void* userData, const unsigned char* buf, unsigned bufLen)
/// {
///     ...
/// }
///
/// mqttsn_gw_session_set_send_data_to_client_cb(handle, &my_send_to_client, someUserData);
/// @endcode
///
/// @subsection mqttsn_gw_session_page_send_broker Sending Data to Broker
/// @b C++ interface:
/// @code
/// session->setSendDataBrokerReqCb(
///     [](const std::uint8_t* buf, std::size_t bufLen)
///     {
///         ... 
///     });
/// @endcode
///
/// @b C interface:
/// @code
/// void my_send_to_broker(void* userData, const unsigned char* buf, unsigned bufLen)
/// {
///     ...
/// }
///
/// mqttsn_gw_session_set_send_data_to_broker_cb(handle, &my_send_to_broker, someUserData);
/// @endcode
///
/// @section mqttsn_gw_session_page_time Time Measurement
/// The @b Session object may require to measure time to identify message delivery
/// timeouts. It relies on the driving code to provide such 
/// service. There is a need to set appropriate callback:
/// 
/// @b C++ interface:
/// @code
/// session.setNextTickProgramReqCb(
///     [](unsigned duration)
///     {
///         ... // Set timer to expire after duration milliseconds
///             // After expiry call session.tick()
///     };
/// @endcode
///
/// @b C interface:
/// @code
/// void my_tick_req(void* userData, unsigned duration)
/// {
///     ... /* Set timer to expire after duration milliseconds */
///     ... /* After expiry call mqttsn_gw_session_tick() */
/// }
///
/// mqttsn_gw_session_set_tick_req_cb(handle, &my_tick_req, someUserData);
/// @endcode
/// 
/// After the requested time expires, the driving code needs to notify the
/// @b Session object. It must call the appropriate @b tick() function.
///
/// @b C++ interface:
/// @code
/// session->tick();
/// @endcode
///
/// @b C interface:
/// @code
/// mqttsn_gw_session_tick(handle); 
/// @endcode
///
/// Based on some events, the @b Session object may require knowledge of elapsed time
/// since last tick programming request. For this purpose the driving code
/// must set a callback to cancel the existing time measurement and return
/// number of elapsed @b milliseconds.
///
/// @b C++ interface:
/// @code
/// session->setCancelTickWaitReqCb(
///     []()
///     {
///         ... // cancel timer
///         return ...; // return number of elapsed milliseconds
///     });
/// @endcode
///
/// @b C interface:
/// @code
/// unsigned my_cancel_timer_req(void* userData)
/// {
///     ... /* cancel timer */
///     return ...; /* return number of elapsed milliseconds */
/// }
///
/// mqttsn_gw_session_set_cancel_tick_cb(handle, &my_cancel_timer_req, someUserData);
/// @endcode
///
/// @section mqttsn_gw_session_page_term Session Termination
/// The @b Session object may recognise disconnection of MQTT-SN client and/or
/// MQTT broker. As the result the session object must be destructed immediately and
/// new one is created once the client renews its connection. The request to
/// terminate the session is performed via callback, which must be set by
/// the driving code.
/// 
/// @b C++ interface:
/// @code
/// session->setTerminationReqCb(
///     []()
///     {
///         ... // Destruct session object.
///     });
/// @endcode
/// 
/// @b C interface:
/// @code
/// void my_session_term(void* userData)
/// {
///     ... /* Remove reference to session object from internal data structures */
///     mqttsn_gw_session_free(handle);
/// }
///
/// mqttsn_gw_session_set_term_req_cb(handle, &my_session_term, someUserData);
/// @endcode
///
/// @section mqttsn_gw_session_page_broker_reconnect Re-Connection to Broker
/// The @b MQTT-SN protocol specification defines messages and operations, that
/// are not properly supported by the @b MQTT protocol, such as will information
/// update. The @b Session object supports these kind of operations by sending updated
/// @b CONNECT request to the broker on behalf of the client. However, MQTT
/// protocol disallows multiple @b CONNECT messages in the single connection
/// session. As the result the gateway must perform the following steps:
///
/// -# send @b DISCONNECT message
/// -# close existing TCP/IP connection
/// -# open new TCP/IP connection
/// -# send new @b CONNECT message with updated connection information.
///
/// Due to the reason, that TCP/IP connection to the broker is managed by
/// the driving code, it must implement steps 2 and 3 in the list above.
///
/// The @b Session object issues the reconnection request via callback, which
/// must be provided by the driving code.
/// 
/// @b C++ interface
/// @code
/// session->setBrokerReconnectReqCb(
///     []()
///     {
///         ... // Close existing TCP/IP connection to broker and open a new one
///     });
/// @endcode
///
/// @b C interface
/// @code
/// void my_broker_reconnect(void* userData)
/// {
///     ... /* Close existing TCP/IP connection to broker and open a new one */
/// }
///
/// mqttsn_gw_session_set_broker_reconnect_req_cb(handle, &my_broker_reconnect, someUserData);
/// @endcode
/// @b NOTE, that the updated connection statuses of the broker (first 
/// disconnected and then connected) must be reported to the @b Session object
/// when they happen. Details are in 
/// @ref mqttsn_gw_session_page_broker_conn section below.
///
/// @section mqttsn_gw_session_page_start Start Operation
///
/// @section mqttsn_gw_session_page_broker_conn Connection to Broker
///


