//
// Copyright 2016 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <list>
#include <vector>
#include <memory>

#include "comms/comms.h"
#include "mqttsn/gateway/Session.h"

CC_DISABLE_WARNINGS()
#include "cxxtest/TestSuite.h"
CC_ENABLE_WARNINGS()

#include "TestMsgHandler.h"

class SessionTest : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();

private:
    typedef std::unique_ptr<mqttsn::gateway::Session> SessionPtr;
    typedef std::vector<std::uint8_t> DataBuf;

    static const std::uint8_t DefaultGwId = 5;
    static const unsigned DefaultRetryPeriod = 15;
    static const unsigned DefaultRetryCount = 3;

    struct State
    {
        std::list<DataBuf> m_sentToClient;
        std::list<DataBuf> m_sentToBroker;
        std::list<unsigned> m_tickReq;
        std::list<unsigned> m_elapsed;
        std::list<bool> m_termRequests;
        std::list<bool> m_brokerReconnectRequests;
    };

    struct WillInfo
    {
        std::string m_topic;
        DataBuf m_msg;
        mqtt::field::QosType m_qos = mqtt::field::QosType::AtMostOnceDelivery;
        bool m_retain = false;
    };

    SessionPtr allocSession(
        State& state,
        TestMsgHandler& handler,
        const std::uint8_t gwId = DefaultGwId,
        const std::string* username = nullptr,
        const DataBuf* password = nullptr)
    {
        SessionPtr session(new mqttsn::gateway::Session);
        if (username != nullptr) {
            std::size_t passLen = 0;
            const std::uint8_t* passPtr = nullptr;
            if (password != nullptr) {
                passPtr = &((*password)[0]);
                passLen = password->size();
            }

            session->setAuthInfo(*username, passPtr, passLen);
        }

        session->setNextTickProgramReqCb(
            [&state](unsigned val) {
                state.m_tickReq.push_back(val);
            });

        session->setCancelTickWaitReqCb(
            [&state]() -> unsigned
            {
                if (state.m_elapsed.empty()) {
                    assert(!"Elapsed timeout is not specified");
                    return 0U;
                }

                auto val = state.m_elapsed.front();
                TS_TRACE("[Elapsed]: " + std::to_string(val));
                state.m_elapsed.pop_front();
                return val;
            });
        session->setSendDataClientReqCb(
            [&state](const std::uint8_t* buf, std::size_t bufSize)
            {
                state.m_sentToClient.emplace_back(buf, buf + bufSize);
            });

        session->setSendDataBrokerReqCb(
            [&state](const std::uint8_t* buf, std::size_t bufSize)
            {
                state.m_sentToBroker.emplace_back(buf, buf + bufSize);
            });

        session->setTerminationReqCb(
            [&state]()
            {
                state.m_termRequests.push_back(true);
            });

        session->setBrokerReconnectReqCb(
            [&state]()
            {
                state.m_brokerReconnectRequests.push_back(true);
            });

        handler.setGwinfoMsgHandler(
            [](const GwinfoMsg_SN&)
            {
                TS_TRACE("<-- GWINFO");
            });

        handler.setConnackMsgHandler(
            [](const ConnackMsg_SN&)
            {
                TS_TRACE("<-- CONNACK");
            });

        handler.setWilltopicreqMsgHandler(
            [](const WilltopicreqMsg_SN&)
            {
                TS_TRACE("<-- WILLTOPICREQ");
            });

        handler.setWillmsgreqMsgHandler(
            [](const WillmsgreqMsg_SN&)
            {
                TS_TRACE("<-- WILLMSGREQ");
            });


        handler.setConnectMsgHandler(
            [](const ConnectMsg&)
            {
                TS_TRACE("<-- CONNECT");
            });

        session->setRetryPeriod(DefaultRetryPeriod);
        session->setRetryCount(DefaultRetryCount);
        session->setGatewayId(gwId);
        bool result = session->start();
        TS_ASSERT(result);
        TS_ASSERT(session->isRunning());
        TS_ASSERT(state.m_sentToClient.empty());
        TS_ASSERT(state.m_sentToBroker.empty());
        TS_ASSERT(state.m_tickReq.empty());
        TS_ASSERT(state.m_elapsed.empty());
        return std::move(session);
    }

    void dataFromClient(
        mqttsn::gateway::Session& session,
        const DataBuf& buf,
        const std::string& msgStr)
    {
        auto consumed = session.dataFromClient(&buf[0], buf.size());
        TS_ASSERT_EQUALS(consumed, buf.size());
        TS_TRACE("(CLIENT) --> " + msgStr);
    }

    void dataFromBroker(
        mqttsn::gateway::Session& session,
        const DataBuf& buf,
        const std::string& msgStr)
    {
        auto consumed = session.dataFromBroker(&buf[0], buf.size());
        TS_ASSERT_EQUALS(consumed, buf.size());
        TS_TRACE("(BROKER) --> " + msgStr);
    }

    static void doTick(State& state, mqttsn::gateway::Session& session)
    {
        if (state.m_tickReq.empty()) {
            TS_FAIL("Tick wan't requested");
            return;
        }

        auto value = state.m_tickReq.front();
        TS_TRACE("[TICK]: " + std::to_string(value));
        state.m_tickReq.pop_front();
        session.tick(value);
    }

    static void checkTickValue(State& state, unsigned value)
    {
        if (state.m_tickReq.empty()) {
            TS_FAIL("Tick wan't requested");
            return;
        }

        TS_ASSERT_EQUALS(state.m_tickReq.front(), value);
    }

    void verifySent_GwinfoMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint8_t gwId)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setGwinfoMsgHandler(
                [&](const GwinfoMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- GWINFO");

                    typedef GwinfoMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& gwIdField = std::get<MsgType::FieldIdx_gwId>(fields);

                    TS_ASSERT_EQUALS(gwIdField.value(), gwId);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setGwinfoMsgHandler(std::move(oldCb));
    }

    void verifySentToClient_ConnackMsg(
        State& state,
        TestMsgHandler& handler,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setConnackMsgHandler(
                [&](const ConnackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- CONNACK");

                    typedef ConnackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setConnackMsgHandler(std::move(oldCb));
    }

    void verifySentToClient_WilltopicreqMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWilltopicreqMsgHandler(
                [&](const WilltopicreqMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLTOPICREQ");
                    static_cast<void>(msg);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWilltopicreqMsgHandler(std::move(oldCb));
    }

    void verifySentToClient_WillmsgreqMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWillmsgreqMsgHandler(
                [&](const WillmsgreqMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLMSGREQ");
                    static_cast<void>(msg);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWillmsgreqMsgHandler(std::move(oldCb));
    }

    void verifySentToBroker_ConnectMsg(
        State& state,
        TestMsgHandler& handler,
        const std::string& clientId,
        std::uint16_t keepAlive,
        bool cleanSession,
        const WillInfo* willInfo = nullptr,
        const std::string& username = std::string(),
        const DataBuf& password = DataBuf())
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setConnectMsgHandler(
                [&](const ConnectMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- CONNECT");

                    typedef ConnectMsg MsgType;
                    auto& fields = msg.fields();
                    auto& flagsField = std::get<MsgType::FieldIdx_Flags>(fields);
                    auto& flagsMembers = flagsField.value();
                    auto& lowFlagsField = std::get<mqtt::message::ConnectFlagsMemberIdx_FlagsLow>(flagsMembers);
                    auto& willQosField = std::get<mqtt::message::ConnectFlagsMemberIdx_WillQos>(flagsMembers);
                    auto& highFlagsField = std::get<mqtt::message::ConnectFlagsMemberIdx_FlagsHigh>(flagsMembers);
                    auto& keepAliveField = std::get<MsgType::FieldIdx_KeepAlive>(fields);
                    auto& clientIdField = std::get<MsgType::FieldIdx_ClientId>(fields);
                    auto& willTopicField = std::get<MsgType::FieldIdx_WillTopic>(fields);
                    auto& willMsgField = std::get<MsgType::FieldIdx_WillMessage>(fields);
                    auto& usernameField = std::get<MsgType::FieldIdx_UserName>(fields);
                    auto& passwordField = std::get<MsgType::FieldIdx_Password>(fields);

                    TS_ASSERT_EQUALS(keepAliveField.value(), keepAlive);
                    TS_ASSERT_EQUALS(clientIdField.value(), clientId);
                    TS_ASSERT_EQUALS(lowFlagsField.getBitValue(mqtt::message::ConnectFlagsLowBitIdx_CleanSession), cleanSession);

                    bool hasWill = (willInfo != nullptr);
                    TS_ASSERT_EQUALS(lowFlagsField.getBitValue(mqtt::message::ConnectFlagsLowBitIdx_WillFlag), hasWill);

                    if (hasWill) {
                        TS_ASSERT_EQUALS(willQosField.value(), willInfo->m_qos);
                        TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_WillRetain), willInfo->m_retain);
                        TS_ASSERT_EQUALS(willTopicField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(willMsgField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(willTopicField.field().value(), willInfo->m_topic);
                        TS_ASSERT_EQUALS(willMsgField.field().value(), willInfo->m_msg);
                    }
                    else {
                        TS_ASSERT_EQUALS(willTopicField.getMode(), comms::field::OptionalMode::Missing);
                        TS_ASSERT_EQUALS(willMsgField.getMode(), comms::field::OptionalMode::Missing);
                    }

                    TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_UserNameFlag), !username.empty());
                    TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_PasswordFlag), !password.empty());

                    if (!username.empty()) {
                        TS_ASSERT_EQUALS(usernameField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(usernameField.field().value(), username);
                    }
                    else {
                        TS_ASSERT_EQUALS(usernameField.getMode(), comms::field::OptionalMode::Missing);
                    }

                    if (!password.empty()) {
                        TS_ASSERT_EQUALS(passwordField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(passwordField.field().value(), password);
                    }
                    else {
                        TS_ASSERT_EQUALS(passwordField.getMode(), comms::field::OptionalMode::Missing);
                    }

                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setConnectMsgHandler(std::move(oldCb));
    }

    void verifyNoOtherEvent(State& state)
    {
        TS_ASSERT(state.m_sentToClient.empty());
        TS_ASSERT(state.m_sentToBroker.empty());
        TS_ASSERT(state.m_tickReq.empty());
        TS_ASSERT(state.m_elapsed.empty());
        TS_ASSERT(state.m_termRequests.empty());
        TS_ASSERT(state.m_brokerReconnectRequests.empty());
    }

    void verifyTickReq(State& state, unsigned value)
    {
        checkTickValue(state, value);
        if (!state.m_tickReq.empty()) {
            state.m_tickReq.pop_front();
        }
    }
};

void SessionTest::test1()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    auto searchgwMsg = handler.prepareSearchgw();
    dataFromClient(*session, searchgwMsg, "SEARCHGW");
    verifySent_GwinfoMsg(state, handler, DefaultGwId);
    verifyNoOtherEvent(state);
}

void SessionTest::test2()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string ClientId("bla");
    static const std::uint16_t KeepAlive = 60;
    static const bool CleanSession = true;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state);

    state.m_elapsed.push_back(1000);
    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_TRACE(state.m_tickReq.front());
    verifyNoOtherEvent(state);
}

void SessionTest::test3()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string ClientId("bla");
    static const std::uint16_t KeepAlive = 60;
    static const bool CleanSession = true;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);

    checkTickValue(state, DefaultRetryPeriod * 1000);
    doTick(state, *session);
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);

    checkTickValue(state, DefaultRetryPeriod * 1000);
    doTick(state, *session);
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);

    checkTickValue(state, DefaultRetryPeriod * 1000);
    doTick(state, *session);
    verifyNoOtherEvent(state);
}

void SessionTest::test4()
{
    static const std::string Username("username");
    static const DataBuf Password = {'p', 'a', 's', 's'};
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler, DefaultGwId, &Username, &Password);

    static const std::string ClientId("blabla");
    static const std::uint16_t KeepAlive = 30;
    static const bool CleanSession = false;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, true, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_WilltopicreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);

    static const std::string WillTopic("this/is/will");
    static const DataBuf WillMsg = {0, 1, 2, 3, 4, 5};
    static const auto WillQos = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const bool WillRetain = false;

    state.m_elapsed.push_back(1000);
    auto willtopicMsg = handler.prepareClientWilltopic(WillTopic, WillQos, WillRetain);
    dataFromClient(*session, willtopicMsg, "WILLTOPIC");
    verifySentToClient_WillmsgreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);

    WillInfo willInfo;
    willInfo.m_topic = WillTopic;
    willInfo.m_msg = WillMsg;
    willInfo.m_qos = mqtt::field::QosType::AtLeastOnceDelivery;
    willInfo.m_retain = WillRetain;

    state.m_elapsed.push_back(1000);
    auto willmsgMsg = handler.prepareClientWillmsg(WillMsg);
    dataFromClient(*session, willmsgMsg, "WILLMSG");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession, &willInfo, Username, Password);
    TS_ASSERT(!state.m_tickReq.empty());

    doTick(state, *session);
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession, &willInfo, Username, Password);
    TS_ASSERT(!state.m_tickReq.empty());
    verifyTickReq(state, state.m_tickReq.front());

    state.m_elapsed.push_back(1000);
    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state);
}

