//
// Copyright 2016 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <list>
#include <vector>
#include <memory>

#include "comms/comms.h"
#include "mqttsn/gateway/Session.h"

CC_DISABLE_WARNINGS()
#include "cxxtest/TestSuite.h"
CC_ENABLE_WARNINGS()

#include "TestMsgHandler.h"

class SessionTest : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();

private:
    typedef std::unique_ptr<mqttsn::gateway::Session> SessionPtr;
    typedef std::vector<std::uint8_t> DataBuf;

    static const std::uint8_t DefaultGwId = 5;
    static const std::uint16_t DefaultKeepAlivePeriod = 60;
    static const unsigned DefaultRetryPeriod = 15;
    static const unsigned DefaultRetryCount = 3;
    static const std::string DefaultClientId;
    static const std::uint16_t DefaultMinTopicId = 1000;
    static const std::uint16_t DefaultMaxTopicId = 2000;

    struct State
    {
        std::list<DataBuf> m_sentToClient;
        std::list<DataBuf> m_sentToBroker;
        std::list<unsigned> m_tickReq;
        std::list<unsigned> m_elapsed;
        std::list<bool> m_termRequests;
        std::list<bool> m_brokerReconnectRequests;
    };

    struct WillInfo
    {
        std::string m_topic;
        DataBuf m_msg;
        mqtt::field::QosType m_qos = mqtt::field::QosType::AtMostOnceDelivery;
        bool m_retain = false;
    };

    static SessionPtr allocSession(
        State& state,
        TestMsgHandler& handler,
        const std::uint8_t gwId = DefaultGwId,
        const std::string* username = nullptr,
        const DataBuf* password = nullptr)
    {
        SessionPtr session(new mqttsn::gateway::Session);
        if (username != nullptr) {
            std::size_t passLen = 0;
            const std::uint8_t* passPtr = nullptr;
            if (password != nullptr) {
                passPtr = &((*password)[0]);
                passLen = password->size();
            }

            session->setAuthInfo(*username, passPtr, passLen);
        }

        session->setNextTickProgramReqCb(
            [&state](unsigned val) {
                state.m_tickReq.push_back(val);
            });

        session->setCancelTickWaitReqCb(
            [&state]() -> unsigned
            {
                if (state.m_elapsed.empty()) {
                    assert(!"Elapsed timeout is not specified");
                    return 0U;
                }

                auto val = state.m_elapsed.front();
                TS_TRACE("[Elapsed]: " + std::to_string(val));
                state.m_elapsed.pop_front();
                return val;
            });
        session->setSendDataClientReqCb(
            [&state](const std::uint8_t* buf, std::size_t bufSize)
            {
                state.m_sentToClient.emplace_back(buf, buf + bufSize);
            });

        session->setSendDataBrokerReqCb(
            [&state](const std::uint8_t* buf, std::size_t bufSize)
            {
                state.m_sentToBroker.emplace_back(buf, buf + bufSize);
            });

        session->setTerminationReqCb(
            [&state]()
            {
                state.m_termRequests.push_back(true);
            });

        session->setBrokerReconnectReqCb(
            [&state]()
            {
                state.m_brokerReconnectRequests.push_back(true);
            });

        handler.setGwinfoMsgHandler(
            [](const GwinfoMsg_SN&)
            {
                TS_TRACE("<-- GWINFO");
            });

        handler.setConnackMsgHandler(
            [](const ConnackMsg_SN&)
            {
                TS_TRACE("<-- CONNACK");
            });

        handler.setWilltopicreqMsgHandler(
            [](const WilltopicreqMsg_SN&)
            {
                TS_TRACE("<-- WILLTOPICREQ");
            });

        handler.setWillmsgreqMsgHandler(
            [](const WillmsgreqMsg_SN&)
            {
                TS_TRACE("<-- WILLMSGREQ");
            });

        handler.setDisconnectSnMsgHandler(
            [](const DisconnectMsg_SN&)
            {
                TS_TRACE("<-- DISCONNECT");
            });

        handler.setRegackMsgHandler(
            [](const RegackMsg_SN&)
            {
                TS_TRACE("<-- REGACK");
            });


        handler.setConnectMsgHandler(
            [](const ConnectMsg&)
            {
                TS_TRACE("<-- CONNECT");
            });

        handler.setDisconnectMsgHandler(
            [](const DisconnectMsg&)
            {
                TS_TRACE("<-- DISCONNECT");
            });

        handler.setPingreqMsgHandler(
            [](const PingreqMsg&)
            {
                TS_TRACE("<-- PINGREQ");
            });

        session->setRetryPeriod(DefaultRetryPeriod);
        session->setRetryCount(DefaultRetryCount);
        session->setGatewayId(gwId);
        session->setTopicIdAllocationRange(DefaultMinTopicId, DefaultMaxTopicId);
        bool result = session->start();
        session->setBrokerConnected(true);
        TS_ASSERT(result);
        TS_ASSERT(session->isRunning());
        TS_ASSERT(state.m_sentToClient.empty());
        TS_ASSERT(state.m_sentToBroker.empty());
        TS_ASSERT(state.m_tickReq.empty());
        TS_ASSERT(state.m_elapsed.empty());
        return std::move(session);
    }

    static void dataFromClient(
        mqttsn::gateway::Session& session,
        const DataBuf& buf,
        const std::string& msgStr)
    {
        auto consumed = session.dataFromClient(&buf[0], buf.size());
        TS_ASSERT_EQUALS(consumed, buf.size());
        TS_TRACE("(CLIENT) --> " + msgStr);
    }

    static void dataFromBroker(
        mqttsn::gateway::Session& session,
        const DataBuf& buf,
        const std::string& msgStr)
    {
        auto consumed = session.dataFromBroker(&buf[0], buf.size());
        TS_ASSERT_EQUALS(consumed, buf.size());
        TS_TRACE("(BROKER) --> " + msgStr);
    }

    static void checkTickValue(State& state, unsigned value)
    {
        if (state.m_tickReq.empty()) {
            TS_FAIL("Tick wan't requested");
            return;
        }

        TS_ASSERT_EQUALS(state.m_tickReq.front(), value);
    }

    static void verifySent_GwinfoMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint8_t gwId)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setGwinfoMsgHandler(
                [&](const GwinfoMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- GWINFO");

                    typedef GwinfoMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& gwIdField = std::get<MsgType::FieldIdx_gwId>(fields);

                    TS_ASSERT_EQUALS(gwIdField.value(), gwId);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setGwinfoMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_ConnackMsg(
        State& state,
        TestMsgHandler& handler,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setConnackMsgHandler(
                [&](const ConnackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- CONNACK");

                    typedef ConnackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setConnackMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_WilltopicreqMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWilltopicreqMsgHandler(
                [&](const WilltopicreqMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLTOPICREQ");
                    static_cast<void>(msg);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWilltopicreqMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_WillmsgreqMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWillmsgreqMsgHandler(
                [&](const WillmsgreqMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLMSGREQ");
                    static_cast<void>(msg);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWillmsgreqMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_DisconnectMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setDisconnectSnMsgHandler(
                [&](const DisconnectMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- DISCONNECT");

                    typedef DisconnectMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& duration = std::get<MsgType::FieldIdx_duration>(fields);
                    TS_ASSERT_EQUALS(duration.getMode(), comms::field::OptionalMode::Missing);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setDisconnectSnMsgHandler(std::move(oldCb));
    }

    static std::uint16_t verifySentToClient_RegackMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t msgId,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return 0U;
        }

        bool sent = false;
        std::uint16_t topicId = 0U;
        auto oldCb =
            handler.setRegackMsgHandler(
                [&](const RegackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- REGACK");

                    typedef RegackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& topicIdField = std::get<MsgType::FieldIdx_topicId>(fields);
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                    topicId = topicIdField.value();
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setRegackMsgHandler(std::move(oldCb));
        return topicId;
    }


    static void verifySentToBroker_ConnectMsg(
        State& state,
        TestMsgHandler& handler,
        const std::string& clientId,
        std::uint16_t keepAlive,
        bool cleanSession,
        const WillInfo* willInfo = nullptr,
        const std::string& username = std::string(),
        const DataBuf& password = DataBuf())
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setConnectMsgHandler(
                [&](const ConnectMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- CONNECT");

                    typedef ConnectMsg MsgType;
                    auto& fields = msg.fields();
                    auto& flagsField = std::get<MsgType::FieldIdx_Flags>(fields);
                    auto& flagsMembers = flagsField.value();
                    auto& lowFlagsField = std::get<mqtt::message::ConnectFlagsMemberIdx_FlagsLow>(flagsMembers);
                    auto& willQosField = std::get<mqtt::message::ConnectFlagsMemberIdx_WillQos>(flagsMembers);
                    auto& highFlagsField = std::get<mqtt::message::ConnectFlagsMemberIdx_FlagsHigh>(flagsMembers);
                    auto& keepAliveField = std::get<MsgType::FieldIdx_KeepAlive>(fields);
                    auto& clientIdField = std::get<MsgType::FieldIdx_ClientId>(fields);
                    auto& willTopicField = std::get<MsgType::FieldIdx_WillTopic>(fields);
                    auto& willMsgField = std::get<MsgType::FieldIdx_WillMessage>(fields);
                    auto& usernameField = std::get<MsgType::FieldIdx_UserName>(fields);
                    auto& passwordField = std::get<MsgType::FieldIdx_Password>(fields);

                    TS_ASSERT_EQUALS(keepAliveField.value(), keepAlive);
                    TS_ASSERT_EQUALS(clientIdField.value(), clientId);
                    TS_ASSERT_EQUALS(lowFlagsField.getBitValue(mqtt::message::ConnectFlagsLowBitIdx_CleanSession), cleanSession);

                    bool hasWill = (willInfo != nullptr);
                    TS_ASSERT_EQUALS(lowFlagsField.getBitValue(mqtt::message::ConnectFlagsLowBitIdx_WillFlag), hasWill);

                    if (hasWill) {
                        TS_ASSERT_EQUALS(willQosField.value(), willInfo->m_qos);
                        TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_WillRetain), willInfo->m_retain);
                        TS_ASSERT_EQUALS(willTopicField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(willMsgField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(willTopicField.field().value(), willInfo->m_topic);
                        TS_ASSERT_EQUALS(willMsgField.field().value(), willInfo->m_msg);
                    }
                    else {
                        TS_ASSERT_EQUALS(willTopicField.getMode(), comms::field::OptionalMode::Missing);
                        TS_ASSERT_EQUALS(willMsgField.getMode(), comms::field::OptionalMode::Missing);
                    }

                    TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_UserNameFlag), !username.empty());
                    TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_PasswordFlag), !password.empty());

                    if (!username.empty()) {
                        TS_ASSERT_EQUALS(usernameField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(usernameField.field().value(), username);
                    }
                    else {
                        TS_ASSERT_EQUALS(usernameField.getMode(), comms::field::OptionalMode::Missing);
                    }

                    if (!password.empty()) {
                        TS_ASSERT_EQUALS(passwordField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(passwordField.field().value(), password);
                    }
                    else {
                        TS_ASSERT_EQUALS(passwordField.getMode(), comms::field::OptionalMode::Missing);
                    }

                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setConnectMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_DisconnectMsg(
        State& state,
        TestMsgHandler& handler)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setDisconnectMsgHandler(
                [&](const DisconnectMsg& msg)
                {
                    static_cast<void>(msg);
                    sent = true;
                    TS_TRACE("(BROKER) <-- DISCONNECT");
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setDisconnectMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PingreqMsg(
        State& state,
        TestMsgHandler& handler)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPingreqMsgHandler(
                [&](const PingreqMsg& msg)
                {
                    static_cast<void>(msg);
                    sent = true;
                    TS_TRACE("(BROKER) <-- PINGREQ");
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPingreqMsgHandler(std::move(oldCb));
    }

    static void verifyBrokerReconnectReq(State& state)
    {
        if (state.m_brokerReconnectRequests.empty()) {
            TS_FAIL("No reconnect requests recorded");
            return;
        }

        TS_TRACE("[Reconnect]");
        state.m_brokerReconnectRequests.pop_front();
    }

    static void verifyTermReq(State& state)
    {
        if (state.m_termRequests.empty()) {
            TS_FAIL("No termination requests recorded");
            return;
        }

        TS_TRACE("[Term]");
        state.m_termRequests.pop_front();
    }

    static void verifyNoOtherEvent(State& state, TestMsgHandler& handler)
    {
        TS_ASSERT(state.m_sentToClient.empty());
        TS_ASSERT(state.m_sentToBroker.empty());
        TS_ASSERT(state.m_tickReq.empty());
        TS_ASSERT(state.m_elapsed.empty());
        TS_ASSERT(state.m_termRequests.empty());
        TS_ASSERT(state.m_brokerReconnectRequests.empty());

        while (!state.m_sentToClient.empty()) {
            handler.processDataForClient(state.m_sentToClient.front());
            state.m_sentToClient.pop_front();
        }

        while (!state.m_sentToBroker.empty()) {
            handler.processDataForBroker(state.m_sentToBroker.front());
            state.m_sentToBroker.pop_front();
        }

        while (!state.m_tickReq.empty()) {
            TS_TRACE("Unexpected tick req: " + std::to_string(state.m_tickReq.front()));
            state.m_tickReq.pop_front();
        }
    }

    static void verifyTickReq(State& state, unsigned value)
    {
        checkTickValue(state, value);
        if (!state.m_tickReq.empty()) {
            state.m_tickReq.pop_front();
        }
    }

    static mqttsn::protocol::field::QosType translateQos(mqtt::field::QosType val)
    {
        return static_cast<mqttsn::protocol::field::QosType>(val);
    }

    static void doTick(State& state, mqttsn::gateway::Session& session, unsigned ms = 0)
    {
        if (ms != 0) {
            TS_TRACE("[TICK]: " + std::to_string(ms));
            TS_ASSERT(state.m_tickReq.size() <= 1U);
            state.m_tickReq.clear();
            session.tick(ms);
            return;
        }

        if (state.m_tickReq.empty()) {
            TS_FAIL("Tick wan't requested");
            return;
        }

        auto value = state.m_tickReq.front();
        TS_TRACE("[TICK]: " + std::to_string(value));
        state.m_tickReq.pop_front();
        session.tick(value);
    }

    static void doConnect(
        mqttsn::gateway::Session& session,
        State& state,
        TestMsgHandler& handler,
        WillInfo* willInfo = nullptr,
        bool cleanSession = true)
    {
        bool hasWill = (willInfo != nullptr);
        auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod, hasWill, cleanSession);
        dataFromClient(session, connectMsg, "CONNECT");

        if (hasWill) {
            verifySentToClient_WilltopicreqMsg(state, handler);
            verifyTickReq(state, DefaultRetryPeriod * 1000);
            verifyNoOtherEvent(state, handler);

            state.m_elapsed.push_back(1000);
            auto willtopicMsg = handler.prepareClientWilltopic(willInfo->m_topic, translateQos(willInfo->m_qos), willInfo->m_retain);
            dataFromClient(session, willtopicMsg, "WILLTOPIC");
            verifySentToClient_WillmsgreqMsg(state, handler);
            verifyTickReq(state, DefaultRetryPeriod * 1000);
            verifyNoOtherEvent(state, handler);

            state.m_elapsed.push_back(1000);
            auto willmsgMsg = handler.prepareClientWillmsg(willInfo->m_msg);
            dataFromClient(session, willmsgMsg, "WILLMSG");
        }

        verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, cleanSession, willInfo);
        verifyNoOtherEvent(state, handler);

        auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
        dataFromBroker(session, connackMsg, "CONNACK");
        verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
        verifyNoOtherEvent(state, handler);
    }

    void doBrokerConnect(mqttsn::gateway::Session& session)
    {
        session.setBrokerConnected(true);
        TS_TRACE("[BROKER connected]");
    }

    void doBrokerDisconnect(mqttsn::gateway::Session& session)
    {
        session.setBrokerConnected(false);
        TS_TRACE("[BROKER disconnected]");
    }

};

const std::string SessionTest::DefaultClientId("client");

void SessionTest::test1()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    auto searchgwMsg = handler.prepareSearchgw();
    dataFromClient(*session, searchgwMsg, "SEARCHGW");
    verifySent_GwinfoMsg(state, handler, DefaultGwId);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test2()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string ClientId("bla");
    static const std::uint16_t KeepAlive = 60;
    static const bool CleanSession = true;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);
    verifyNoOtherEvent(state, handler);

    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test3()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string ClientId("bla");
    static const std::uint16_t KeepAlive = 60;
    static const bool CleanSession = true;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);
    verifyNoOtherEvent(state, handler);

    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);
    verifyNoOtherEvent(state, handler);

    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);


    static const std::uint16_t KeepAlive2 = 120;
    static const bool CleanSession2 = false;

    auto connectMsg2 = handler.prepareClientConnect(ClientId, KeepAlive2, false, CleanSession2);
    dataFromClient(*session, connectMsg2, "CONNECT");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyBrokerReconnectReq(state);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(500);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 500);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive2, CleanSession2);
    verifyNoOtherEvent(state, handler);

    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    static const std::string ClientId2 = "blablabla";
    auto connectMsg3 = handler.prepareClientConnect(ClientId2, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg3, "CONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test4()
{
    static const std::string Username("username");
    static const DataBuf Password = {'p', 'a', 's', 's'};
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler, DefaultGwId, &Username, &Password);

    static const std::string ClientId("blabla");
    static const std::uint16_t KeepAlive = 30;
    static const bool CleanSession = false;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, true, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_WilltopicreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);

    static const std::string WillTopic("this/is/will");
    static const DataBuf WillMsg = {0, 1, 2, 3, 4, 5};
    static const auto WillQos = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const bool WillRetain = false;

    state.m_elapsed.push_back(1000);
    auto willtopicMsg = handler.prepareClientWilltopic(WillTopic, WillQos, WillRetain);
    dataFromClient(*session, willtopicMsg, "WILLTOPIC");
    verifySentToClient_WillmsgreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);

    WillInfo willInfo;
    willInfo.m_topic = WillTopic;
    willInfo.m_msg = WillMsg;
    willInfo.m_qos = mqtt::field::QosType::AtLeastOnceDelivery;
    willInfo.m_retain = WillRetain;

    state.m_elapsed.push_back(1000);
    auto willmsgMsg = handler.prepareClientWillmsg(WillMsg);
    dataFromClient(*session, willmsgMsg, "WILLMSG");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession, &willInfo, Username, Password);

    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::BadUsernameOrPassword);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_NotSupported);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test5()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    auto disconnectSnMsg = handler.prepareClientDisconnect();
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);

    session = allocSession(state, handler);
    doConnect(*session, state, handler);

    auto disconnectMsg = handler.prepareBrokerDisconnect();
    dataFromBroker(*session, disconnectMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);

    session = allocSession(state, handler);
    doConnect(*session, state, handler);
    doBrokerDisconnect(*session);
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test6()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, DefaultRetryPeriod * 1000);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, expectedTickReq - 1000);
    verifyTickReq(state, 1000);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, 1000);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test7()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(2000);
    auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod, false, false);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test8()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string WillTopic("will/topic");
    static const DataBuf WillMsg = {0x1, 0x2, 0x3};
    static const auto WillQos = mqtt::field::QosType::AtMostOnceDelivery;
    static const bool WillRetain = false;
    WillInfo willInfo;
    willInfo.m_topic = WillTopic;
    willInfo.m_msg = WillMsg;
    willInfo.m_qos = WillQos;
    willInfo.m_retain = WillRetain;

    doConnect(*session, state, handler, &willInfo);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(2000);
    auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod * 2, false, false);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, state.m_tickReq.front()); // remains from the asleep state.
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(500);
    doBrokerDisconnect(*session);
    verifyTickReq(state, state.m_tickReq.front()); // remains from the asleep state.
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(500);
    doBrokerConnect(*session);
    verifyTickReq(state, state.m_tickReq.front()); // remains from the asleep state.
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod * 2, false, &willInfo);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test9()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t MsgId = 0x1122;
    auto registerMsg = handler.prepareClientRegister(Topic, MsgId);
    dataFromClient(*session, registerMsg, "REGISTER");
    auto topicId = verifySentToClient_RegackMsg(state, handler, MsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_LESS_THAN_EQUALS(DefaultMinTopicId, topicId);
    TS_ASSERT_LESS_THAN_EQUALS(topicId, DefaultMaxTopicId);
    verifyNoOtherEvent(state, handler);

    auto registerMsg2 = handler.prepareClientRegister(Topic, MsgId + 1);
    dataFromClient(*session, registerMsg2, "REGISTER");
    auto topicId2 = verifySentToClient_RegackMsg(state, handler, MsgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_EQUALS(topicId, topicId2);
    verifyNoOtherEvent(state, handler);
}
